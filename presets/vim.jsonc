/**
# Vim key bindings

This preset file contains bindings that emulate Vim's normal mode commands.
Note that commands bound to `Ctrl+`_X_ are missing because they need to be
added to VS Code's standard `keybindings.json` file.

## Insert mode - inserting/appending text

- `i` insert before the cursor
- `I` insert at the beginning of the line
- `a` insert (append) after the cursor
- `A` insert (append) at the end of the line
- `o` append (open) a new line below the current line
- `O` append (open) a new line above the current line
- `ea` insert (append) at the end of the word
*/
{
    "i": "modaledit.enterInsert",
    "I": [
        "cursorHome",
        "modaledit.enterInsert"
    ],
    "a": [
        {
            "condition": "__char == 0",
            "false": "cursorRight"
        },
        "modaledit.enterInsert"
    ],
    "A": [
        "cursorEnd",
        "modaledit.enterInsert"
    ],
    "o": [
        "editor.action.insertLineAfter",
        "modaledit.enterInsert"
    ],
    "O": [
        "editor.action.insertLineBefore",
        "modaledit.enterInsert"
    ],
/**
## Visual Mode
*/
    "v": "modaledit.toggleSelection",
    "V": "expandLineSelection",
/**
## Cursor Movement
*/
    "h": {
        "command": "cursorMove",
        "args": "{ to: 'left', select: __selecting }"
    },
    "j": {
        "command": "cursorMove",
        "args": "{ to: 'down', select: __selecting }"
    },
    "k": {
        "command": "cursorMove",
        "args": "{ to: 'up', select: __selecting }"
    },
    "l": {
        "command": "cursorMove",
        "args": "{ to: 'right', select: __selecting }"
    },
/**
## Moving Inside Screen
*/
    "H": {
        "command": "cursorMove",
        "args": "{ to: 'viewPortTop', select: __selecting }"
    },
    "M": {
        "command": "cursorMove",
        "args": "{ to: 'viewPortCenter', select: __selecting }"
    },
    "L": {
        "command": "cursorMove",
        "args": "{ to: 'viewPortBottom', select: __selecting }"
    },
/**
## Jumping to Previous/Next Word
*/
    "w": {
        "condition": "__selecting",
        "true": "cursorWordStartRightSelect",
        "false": "cursorWordStartRight"
    },
    "b": {
        "condition": "__selecting",
        "true": "cursorWordStartLeftSelect",
        "false": "cursorWordStartLeft"
    },
    "e": {
        "condition": "__selecting",
        "true": "cursorWordEndRightSelect",
        "false": "cursorWordEndRight"
    },
/**
> **Note**: We omit variants of these commands `W`, `B`, and `E` which skip the 
> punctuation characters. There are no built-in commands in VS Code that work
> exactly like those in Vim. This is one of the subtle differences between the 
> editors.

### Jumping to Start/End of Line

In the similar vein, we'll throw in commands for jumping to the beginning `0`, 
to the first non-blank character `^`, and to the end of line `$`.
*/
    "0": {
        "command": "cursorMove",
        "args": "{ to: 'wrappedLineStart', select: __selecting }"
    },
    "^": {
        "command": "cursorMove",
        "args": "{ to: 'wrappedLineFirstNonWhitespaceCharacter', select: __selecting }"
    },
    "$": {
        "command": "cursorMove",
        "args": "{ to: 'wrappedLineEnd', select: __selecting }"
    },
    /**
A lesser known variant of above commands is `g_` that jumps to the last 
non-blank character of the line. Since it is a two key sequence we need to 
open a block for all commands beginning with `g`.
*/
    "g": {
        "_": {
            "command": "cursorMove",
            "args": "{ to: 'wrappedLineLastNonWhitespaceCharacter', select: __selecting }"
        },
        /**
### Jumping to Start/End of Document

Another command beginning with `g` is `gg` which jumps to the beginning of the
file.
*/
        "g": {
            "condition": "__selecting",
            "true": "cursorTopSelect",
            "false": "cursorTop"
        },
    },
    /**
The opposite of that is `G` wich jumps to the end of file.
*/
    "G": {
        "condition": "__selecting",
        "true": "cursorBottomSelect",
        "false": "cursorBottom"
    },
    /**
### Jump to Character

We have the basic movement commands covered, so let's move on to more 
sophisticated ones. Seasoned Vim users avoid hitting movement commands
repeatedly by using `f` and `F` keys which move directly to a given character.
VS Code provides no built-in command for this, but ModalEdit includes an 
incremental search command which can be customized to this purpose.
*/
    "f": {
        "condition": "__selecting",
        "true": {
            "command": "modaledit.search",
            "args": {
                "caseSensitive": true,
                "acceptAfter": 1,
                "selectTillMatch": true,
            }
        },
        "false": {
            "command": "modaledit.search",
            "args": {
                "caseSensitive": true,
                "acceptAfter": 1,
                "typeAfterAccept": "h",
            }
        },
    },
    /**
The command is a bit involved, so let's explain what each argument does.

- `caseSensitive` sets the search mode to case sensitive (as in Vim).
- `acceptAfter` ends the incremental search as soon as first entered character
  is found. Normally the user needs to press `Enter` to accept the search or
  `Esc` to cancel it.
- `selectTillMatch` argument controls whether selection is extended until the
  searched character. This depends on whether we have selection mode on or not.
- `typeAfterAccept` argument allows you to run other commands (using their key
  bindings) after the search is done. By default, `modalEdit.search` command 
  selects the found character(s). With `h` command we move the cursor over the
  searched character.
  
Now we can implement the opposite `F` command which searches for the previous 
character. The `backwards` parameter switches the search direction.
*/
    "F": {
        "condition": "__selecting",
        "true": {
            "command": "modaledit.search",
            "args": {
                "caseSensitive": true,
                "acceptAfter": 1,
                "selectTillMatch": true,
                "backwards": true,
            }
        },
        "false": {
            "command": "modaledit.search",
            "args": {
                "caseSensitive": true,
                "acceptAfter": 1,
                "typeAfterAccept": "h",
                "backwards": true
            }
        },
    },
    /**
With `;` and `,` keys you can repeat the previous `f` or `F` commands either 
forwards or backwards.
*/
    ";": "modaledit.nextMatch",
    ",": "modaledit.previousMatch",
    /**
> We omitted few useful jump commands, like `t`, `T`, `{`, and `}` as there are
> no corresponding commands in available in VS Code. You can always look for 
> other [extensions][] that provide similar functionality.

### Center Cursor on Screen

The last movement command we add is `zz` that scrolls the screen so that cursor
is at the center. Again, the ability to use JS expression in arguments comes in 
handy. We use the `__line` parameter to get the line where the cursor is.
*/
    "z": {
        "z": {
            "command": "revealLine",
            "args": "{ lineNumber: __line, at: 'center' }"
        }
    },
    /**
Let's test some of the movement commands. We should be able to navigate now 
without using arrow keys or `Home` and `End` keys.

![Navigation](../images/cursor-movement.gif)

We skipped commands that move cursor up and down on page at the time. The
reason for this is that these commands are bound to `Ctrl+b` and `Ctrl+f` in
Vim. Since these are "normal" VS Code shortcuts we cannot remap them in 
ModalEdit. If you want to use these shortcuts, you need to add the bindings to 
the VS Code's `keybindings.json` file. Below is an example that uses the
`modaledit.normal` context to make the shortcuts work only in normal mode. Most 
of the Vim's standard `Ctrl`+key combinations are already in use, so you 
need to decide whether you want to remap the existing commands first.
```js
// keybindings.json
{
    {
        "key": "ctrl+b",
        "command": "cursorPageUp",
        "when": "editorTextFocus && modaledit.normal"
    },
    {
        "key": "ctrl+f",
        "command": "cursorPageDown",
        "when": "editorTextFocus && modaledit.normal"
    }
}
```
## Commands with Counts

Some commands allow repeating them by typing first a number. For example, `3j`
moves the cursor down three lines. Implementing these kind of commands is 
possible starting from ModalEdit version 1.5 which introduced key ranges and 
[recursive keymaps][].

First of all, we define a keymap that is activated when pressing a number key
`1-9`. We give the keymap an unique `id` which we can then recursively "call".
We also add a `help` string that is shown in the status when the keymap is 
active (after user has pressed a number key).

Then we define the recursive part; we want to stay in the same keymap as long
as user presses another number key. We implement this by defining inner key 
range `0-9` which maps to the `id` 1. Whenever you specify a number as the 
target for a mapping, ModalEdit treats it as an `id` that has to be assigned to 
a previously defined keymap. In this case we map back to the same keymap, but
you can also jump to other keymaps too.

When the user presses some other than numeric key, we break out from the loop
and run an actual command. The number that was typed is stored in the `__keys`
variable which is available to all JS expressions. In this case we use it to get 
the repeat count as a number. The JS expression in the `repeat` argument does 
just this. We also get the actual command from the last item of the `__keys`
array and pass it to the `modaledit.typeNormalKeys` which runs the command 
mapped to the key.
*/
    "1-9": {
        "id": 1,
        "help": "Enter count followed by [h,j,k,l,w,b,e]",
        "0-9": 1,
        "h,j,k,l,w,b,e": {
            "command": "modaledit.typeNormalKeys",
            "args": "{ keys: __keys[__keys.length - 1] }",
            "repeat": "Number(__keys.slice(0, -1).join(''))"
        },
        /**
With this one reletively simply mapping we can implement the repeating 
functionality for any command that we have already defined.

### Jumping to Line

Another command that has a number prefix is _x_`G` where _x_ is the line number
you want to jump to. Let's add that as well in the same keymap. While the 
mapping is trivial the command itself is a bit involved, because we need to use
two commands to do the jumping. First we move the target line to the top of the
screen, and then we move the cursor to the same line. Unfortunately the 
built-in command `workbench.action.gotoLine` does not take any arguments, so 
we have to reinvent the wheel.
*/
        "G": [
            {
                "command": "revealLine",
                "args": "{ lineNumber: Number(__keys.slice(0, -1).join('')) - 1, at: 'top' }"
            },
            {
                "command": "cursorMove",
                "args": {
                    "to": "viewPortTop"
                }
            }
        ]
    },
    /**
## Editing

Now we'll implement Vim's common editing commands. We only add the ones that 
have counterparts in VS Code. 

### Joining Lines

`J` joins current and next line together.
*/
    "J": "editor.action.joinLines",
    /**
### Changing Text

_Change_ commands delete some text and then enter insert mode. `cc` changes the 
current line (or all selected lines), `c$` changes the text from the cursor to 
the end of line, and `cw` changes the end of the word. Three key sequnce `ciw`
changes the whole word under the cursor.
*/
    "c": {
        "c": [
            "deleteAllLeft",
            "deleteAllRight",
            "modaledit.enterInsert"
        ],
        "$": [
            "deleteAllRight",
            "modaledit.enterInsert"
        ],
        "w": [
            "deleteWordEndRight",
            "modaledit.enterInsert"
        ],
        /**
### Change Until/Around/Inside

Very useful variants of change commands are those which allow changing text
upto a given character or between given characters. For example, `ct_` changes 
the text until next underscore, and `ci"` changes the text inside quotation 
marks. The cursor can be anywhere inside the quotation marks and the command 
still works.

To help implement these type of operations version 1.6 included the 
[`modaledit.selectBetween` command][selectBetween]. It is a swiss army knife 
type of command that serves many use cases. We use it first to implement the 
"change until" commands: `ct`_x_ changes the text fromthe cursor till the next 
occurrence of _x_. `cf`_x_ does the same and deletes _x_ too.
*/
        "t,f": {
            "help": "Change until _",
            " -~": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ to: __keys[2], inclusive: __keys[1] == 'f' }"
                },
                "deleteLeft",
                "modaledit.enterInsert"
            ]
        },
        /**
We exploit key ranges to capture all visible ASCII character from spacebar to
tilde. We find the next occurrence of the character typed last (found in 
`__keys[2]`) and select the range. Note that `selectBetween` only searches till 
the end of the current line by default. If you want to search till the end of 
the whole document, set the `docScope` flag to `true`. When only the `to` 
argument is specified, the selection starts from the cursor position.

If the user pressed `f` instead of `t` as the second key in the sequence, we
set the `inclusive` flag to true. That extends the selection over the searched
character.

Next we add the change around/inside commands. The first variant takes care of
the characters that are not braces.
*/
        "a,i": {
            "help": "Change around/inside _",
            " -/,:-@,[-`,{-~": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: __keys[2], to: __keys[2], inclusive: __keys[1] == 'a' }"
                },
                "deleteLeft",
                "modaledit.enterInsert"
            ],
            /**
The rather cryptic key range captures all visible non-alphanumeric ASCII 
characters. The rest of the command is exactly same as in the previous example.
The only difference is that we store the character to be searched into both 
`from` and `to` arguments.

Now we can add the commands that change text inside braces, such as `ci{` or
`ca]`.
*/
            "(,)": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '(', to: ')', inclusive: __keys[1] == 'a' }"
                },
                "deleteLeft",
                "modaledit.enterInsert"
            ],
            "{,}": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '{', to: '}', inclusive: __keys[1] == 'a' }"
                },
                "deleteLeft",
                "modaledit.enterInsert"
            ],
            "[,]": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '[', to: ']', inclusive: __keys[1] == 'a' }"
                },
                "deleteLeft",
                "modaledit.enterInsert"
            ],
            "<,>": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '<', to: '>', inclusive: __keys[1] == 'a' }"
                },
                "deleteLeft",
                "modaledit.enterInsert"
            ],
            /**
It is also useful to be able to change the current word the cursor is on. You
can do this by typing `ciw` (preserves separators) or `caw`. We use regular
expressions as the delimiters in this case. The `\N` regular expression matches
all non-alphanumeric characters (except underscore). Note the double escaping 
needed to enter the `\` character. There are other commands we could use to 
implement the operation, but this version works reliably in all scenarios. 
*/
            "w": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '\\\\W', to: '\\\\W', regex: true, inclusive: __keys[1] == 'a' }"
                },
                "deleteLeft",
                "modaledit.enterInsert"
            ]
        }
    },
    /**
> We could also implement delete commands `diw`, `dt-`, etc. in the similar
> fashion. But for the sake of keeping the tutorial short, we'll leave those
> as an exercise.

A shorthand for `c$` command is `C`.
*/
    "C": [
        "deleteAllRight",
        "modaledit.enterInsert"
    ],
    /**
_Substitution_ commands do  basically same things as change commands; `s` 
changes the character under cursor, and `S` is same as `cc`.
*/
    "s": [
        "deleteRight",
        "modaledit.enterInsert"
    ],
    "S": [
        "deleteAllLeft",
        "deleteAllRight",
        "modaledit.enterInsert"
    ],
    /**
### Undo & Redo

You can undo the last change with `u`. We also clear the selection to copy Vim's 
operation.
*/
    "u": [
        "undo",
        "modaledit.cancelSelection"
    ],
    /**
Since redo is mapped to `Ctrl+r" by default, we leave this binding as an 
exercise to the reader.

## Visual (Selection) Commands

Visual commands operate on the selected text. `<` and `>` shift selected text
left or right (indent/outdent).
*/
    "<": "editor.action.outdentLines",
    ">": "editor.action.indentLines",
    /**

### Clipboard Commands

`y` yanks, i.e. copies, selected text to clipboard. Following Vim convention, we 
also clear the selection.
*/
    "y": [
        "editor.action.clipboardCopyAction",
        "modaledit.cancelSelection"
    ],
    /**
`d` deletes (cuts) the selected text and puts it to clipboard. Capital `D` 
deletes the rest of the line. `x` deletes just the character under the cursor.
*/
    "d": "editor.action.clipboardCutAction",
    "D": [
        "cursorEndSelect",
        "editor.action.clipboardCutAction"
    ],
    "x": [
        "cursorRightSelect",
        "editor.action.clipboardCutAction"
    ],
    /**
> **Note**: If there is no text selected, `y` and `d` commands perform exactly
> the same actions as `yy` and `dd` in Vim. That is, they yank or delete the 
> current line. Again, one of the subtle differences that is futile to try to
> unify.

For pasting (or _putting_ in Vim parlance) the text in clipboard you have two 
commands: `p` puts the text after the cursor, and `P` puts it before.
*/
    "p": [
        "cursorRight",
        "editor.action.clipboardPasteAction"
    ],
    "P": "editor.action.clipboardPasteAction",
    /**
### Switching Case

Switching selected text to upper or lower case is done with a nifty trick.
We can examine the selection in a conditional command that calls different VS 
Code commands based on the expression. The command is bound to the tilde `~` 
character. 
*/
    "~": {
        "condition": "__selection == __selection.toUpperCase()",
        "true": "editor.action.transformToLowercase",
        "false": "editor.action.transformToUppercase"
    },
    /**
## Marks

Marks or bookmarks, as they are more commonly known, provide a handy way to 
jump quickly inside documents. Surprisingly, VS Code does not contain this
feature out-of-the-box. Since it is easy to implement, ModalEdit fills the gap 
and adds two simple commands: `modaledit.defineBookmark` and 
`modaledit.goToBookmark`. Using these we can implement Vim's mark commands.

We can support dozens of bookmarks with one mapping using a character range.
To define a bookmark, you type `ma`, for example, and to jump to that mark, 
type `` `a``.
*/
    "m": {
        "a-z": {
            "command": "modaledit.defineBookmark",
            "args": "{ bookmark: __keys[1] }"
        }
    },
    "`": {
        "a-z": {
            "command": "modaledit.goToBookmark",
            "args": "{ bookmark: __keys[1] }"
        }
    },
    /**
## Searching

The last category of commands we implement is searching. We use the incremental
search command provided by ModalEdit for this. As in Vim, typing `/` starts an 
incremental search. `?` starts a search backwards.
*/
    "/": {
        "command": "modaledit.search",
        "args": {
            "caseSensitive": true
        }
    },
    "?": {
        "command": "modaledit.search",
        "args": {
            "caseSensitive": true,
            "backwards": true
        }
    },
    /**
Jumping to next previous match is done with keys `n` and `N`.
*/
    "n": "modaledit.nextMatch",
    "N": "modaledit.previousMatch"
}
/**
There are some subtle differences in the search functionality as well. Instead 
of just highlighting matches ModalEdit selects them. This is preferable 
anyway, as replacing needs to be done manually with selection commands. Finally, 
`modaledit.search` does not support regexes. Use VS Code's built-in find 
command, if you need regex support.

## Conclusion

We have built far from complete but nevertheless usable Vim emulation which
you can tweak in various ways to make it better. The point of this exercise was
to show that you can significantly enhance VS Code's editing experience using 
just a simple extension and built-in commands.

When writing ModalEdit my goal was not to provide a new Vim emulation. In fact, 
I don't use Vim-style key bindings myself. I find the countless keyboard 
combinations in Vim superfuous and inconsistent. I doubt that anybody knows, let 
alone _uses_ all the available commands. Using Vim is like working in a 
workshop where you have shelves full of bench planes but the only tool you 
really need is your trusty No 4 Stanley.

![WTF?](../images/wood-planes.jpg)

What I am trying to demonstrate is that you don't need to learn all the magical 
Vim facilities to become better at editing. Just keep an eye on what operations 
you repeat, and think how you could make them more efficient. Then add commands 
that will speed up those operations. Try to make the new commands as general as 
possible, and as easy as possible to use. Your text editor should adapt to your 
way of working, not the other way around.  

The thing that Vim got right, though, is modal editing. It is the laser beam 
on the great white shark's head that really makes it cool. Modal editing puts
all the commands at your fingertips, and makes you faster. That is why Vim is 
still popular, even though there is lot of competition around. So, the obvious 
conclusion is to equip modern editors like VS Code with the same frickin' 
laser beam. It requires some training to operate, but when properly configured
will cut through text at the speed of light.

Happy Editing! ðŸ¦ˆðŸ˜Ž
*/
