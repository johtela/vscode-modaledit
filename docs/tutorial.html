
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ModalEdit - Tutorial</title>
    <link rel="icon" type="image/icon" href="images/favicon.png" />
    <link rel="stylesheet" href="css/main.css" />
    
    
</head>
<body>
    
    <div class="navbar">
        <div class="navmenu">
            
    <a class="title enabled" href="index.html">
        <img src="images/escape.svg" />
        <span>ModalEdit</span>
    </a>
    <a class="enabled" href="https://marketplace.visualstudio.com/items?itemName=johtela.vscode-modaledit">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><path d="M537.6 226.6c4.1-10.7 6.4-22.4 6.4-34.6 0-53-43-96-96-96-19.7 0-38.1 6-53.3 16.2C367 64.2 315.3 32 256 32c-88.4 0-160 71.6-160 160 0 2.7.1 5.4.2 8.1C40.2 219.8 0 273.2 0 336c0 79.5 64.5 144 144 144h368c70.7 0 128-57.3 128-128 0-61.9-44-113.6-102.4-125.4zm-132.9 88.7L299.3 420.7c-6.2 6.2-16.4 6.2-22.6 0L171.3 315.3c-10.1-10.1-2.9-27.3 11.3-27.3H248V176c0-8.8 7.2-16 16-16h48c8.8 0 16 7.2 16 16v112h65.4c14.2 0 21.4 17.2 11.3 27.3z"/></svg>
        <span>Download</span>
    </a>
    <a class="enabled" href="https://github.com/johtela/vscode-modaledit">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
        <span>GitHub</span>
    </a>
    <a class="enabled" href="LICENSE.html">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zM64 72c0-4.42 3.58-8 8-8h80c4.42 0 8 3.58 8 8v16c0 4.42-3.58 8-8 8H72c-4.42 0-8-3.58-8-8V72zm0 64c0-4.42 3.58-8 8-8h80c4.42 0 8 3.58 8 8v16c0 4.42-3.58 8-8 8H72c-4.42 0-8-3.58-8-8v-16zm192.81 248H304c8.84 0 16 7.16 16 16s-7.16 16-16 16h-47.19c-16.45 0-31.27-9.14-38.64-23.86-2.95-5.92-8.09-6.52-10.17-6.52s-7.22.59-10.02 6.19l-7.67 15.34a15.986 15.986 0 0 1-14.31 8.84c-.38 0-.75-.02-1.14-.05-6.45-.45-12-4.75-14.03-10.89L144 354.59l-10.61 31.88c-5.89 17.66-22.38 29.53-41 29.53H80c-8.84 0-16-7.16-16-16s7.16-16 16-16h12.39c4.83 0 9.11-3.08 10.64-7.66l18.19-54.64c3.3-9.81 12.44-16.41 22.78-16.41s19.48 6.59 22.77 16.41l13.88 41.64c19.77-16.19 54.05-9.7 66 14.16 2.02 4.06 5.96 6.5 10.16 6.5zM377 105L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128v-6.1c0-6.3-2.5-12.4-7-16.9z"/></svg>
        <span>License</span>
    </a>
    <a class="enabled" href="README.html">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M223.7 239l136-136c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9L319.9 256l96.4 96.4c9.4 9.4 9.4 24.6 0 33.9L393.7 409c-9.4 9.4-24.6 9.4-33.9 0l-136-136c-9.5-9.4-9.5-24.6-.1-34zm-192 34l136 136c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9L127.9 256l96.4-96.4c9.4-9.4 9.4-24.6 0-33.9L201.7 103c-9.4-9.4-24.6-9.4-33.9 0l-136 136c-9.5 9.4-9.5 24.6-.1 34z"/></svg>
        <span>Previous: Home</span>
    </a>
    <a class="enabled" href="src/extension.html">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34zm192-34l-136-136c-9.4-9.4-24.6-9.4-33.9 0l-22.6 22.6c-9.4 9.4-9.4 24.6 0 33.9l96.4 96.4-96.4 96.4c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l136-136c9.4-9.2 9.4-24.4 0-33.8z"/></svg>
        <span>Next: Extension</span>
    </a>
        </div>
        
    <a class="hamburger">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
    </a>
    </div>
    
    <div class="layout">
        <div class="sidepane collapsible">
            
    <div class="tocmenu">
        <h3>Table of Contents</h3>
        
    <ul>
        
    <li>
        
        <a href="README.html">Home</a>
        
    </li>
    <li>
        
        <a href="tutorial.html" class="highlight">Tutorial</a>
        
    </li>
    <li>
        <button class="accordion">
        Implementation
        </button>
            
    <ul>
        
    <li>
        
        <a href="src/extension.html">Extension</a>
        
    </li>
    <li>
        
        <a href="src/actions.html">Actions</a>
        
    </li>
    <li>
        
        <a href="src/commands.html">Commands</a>
        
    </li>
    </ul>
    </li>
    <li>
        
        <a href="CHANGELOG.html">Changelog</a>
        
    </li>
    <li>
        
        <a href="LICENSE.html">License</a>
        
    </li>
    </ul>
    </div>
            
    <div class="footer">
        Copyright Â© 2020 Tommi Johtela
        <div class="ad">
            Created with <a href="https://github.com/johtela/litscript">LiTScript</a>
        </div>
    </div>

        </div>
        <div class="sideicon collapsible">
            
    <a class="hamburger">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
    </a>
        </div>
        <div class="scrollingarea closepopups">
            
    <div class="contentarea">
        <h1 id="build-your-own-vim-emulation-for-vs-code">Build Your Own Vim Emulation for VS Code</h1>
<p><img src="../images/sharks.png" alt="Shark" width="256" height="206">
<a href="https://www.vim.org/">Vim</a> is the great white shark of text editors. It has survived among modern
IDEs because of its unique philosophy. It supports <a href="https://unix.stackexchange.com/questions/57705/modeless-vs-modal-editors">modal editing</a> which is
almost an opposite approach to how other editors work. You start in &quot;normal&quot;
mode where you can navigate and edit text but not insert it. When you want to
enter text, you switch to &quot;insert&quot; mode where you can type new text but do
nothing else. So, you end up bouncing between modes as you edit your file.</p>
<p>This might sound difficult, and granted, the learning curve is steep. But after
you are accustomed to this way of editing, it is very difficult to go back. For
example, having to use arrow keys to move cursor feels uncomfortable. The proof
of this is that nearly all popular text editors have some kind of add-in that
provides Vim emulation. VS Code has several of them.</p>
<p>So, why write yet another extension that provides Vim emulation? Well, the
problem is that most emulators try to make VS Code behave exactly like Vim which
quickly becomes an exercise in futility. Trying to mimick Vim's functionality
too closely results in disjointed user experience as it has a lot of features
that do not have counterparts in VS Code.</p>
<p><a href="../README.html">ModalEdit's</a> approach is to utilize VS Code's existing features and
just add the concept of modal editing to the mix. Turns out implementing modal
editing is extremely simple. We basically provide pair of commands that switch
between normal mode and insert mode.</p>
<p>To complete the feature set, we need an ability to bind normal mode key
sequences to VS Code's commands. ModalEdit accomplishes this by defining the key
bindings in the VS Code's standard configuration file <code>settings.json</code>. It allows
binding any key to any command, or a sequence of commands. It supports also
conditional commands that do different things based on editor state. Refer to
the <a href="../README.html">README</a> page for the details of the configuration options.</p>
<p>With these capabilities we can start building our Vim emulation. We don't have
to use Vim's standard key bindings, if we prefer not to. You can map any key
(sequence) to any command. But to keep things familiar, we'll follow Vim's
conventions in this tutorial.</p>
<p>Let's start configuring our Vim emulator by adding the ModalEdit's configuration
block for key bindings. We'll use the <a href="https://vim.rtorr.com/">Vim Cheat Sheet</a> as our specification
for key bindings to be added.</p>

<pre class="syntaxhighlight"><code>{
    <span class="string">"modaledit.keybindings"</span>: {
</code></pre>
<h2 id="switching-between-modes">Switching Between Modes</h2>
<p>First things first: we need to be able to enter the normal mode somehow. The
<code>Esc</code> key is mapped to the <code>modaledit.enterNormal</code> command by default, so we
dont't need to do anything for that. If you like, you can map other keys to
this command using VS Code's standard keymappings pressing <code>Ctrl+K Ctrl+S</code>.</p>
<h3 id="insert-text">Insert Text</h3>
<p>There are multiple ways to enter insert mode. If you want to insert text in the
current cursor position, you press <code>i</code>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"i"</span>: <span class="string">"modaledit.enterInsert"</span>,
</code></pre>
<p>To insert text at the beginning of line, you press <code>I</code>. For this operation, we
need a command sequence, i.e. an array of commands.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"I"</span>: [
            <span class="string">"cursorHome"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
</code></pre>
<h3 id="append-text">Append Text</h3>
<p><em>Appending</em> text works analogously; <code>a</code> appends text after current character
and <code>A</code> at the end of the line. There is a special case, though. If cursor is
already at the last character of the line, it should not move. This is why we
use a conditional command to move the cursor only, if the current character
is not an empty string which marks the end of the line. A conditional command
is an object that contains the <code>condition</code> property. The value of the property
is a JS expression which ModalEdit evaluates. It selects the command based on
the result. In this case, the result <code>false</code> will execute the <code>cursorRight</code>
command.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"a"</span>: [
            {
                <span class="string">"condition"</span>: <span class="string">"__char == ''"</span>,
                <span class="string">"false"</span>: <span class="string">"cursorRight"</span>
            },
            <span class="string">"modaledit.enterInsert"</span>
        ],
        <span class="string">"A"</span>: [
            <span class="string">"cursorEnd"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
</code></pre>
<h3 id="open-a-new-line">Open a New Line</h3>
<p>The third way to enter insert mode is to <em>open</em> a line. This means creating an
empty line, and putting the cursor on it. There are two variants of this command
as well: <code>o</code> opens a new line below the current line whereas <code>O</code> opens it on the
current line.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"o"</span>: [
            <span class="string">"editor.action.insertLineAfter"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
        <span class="string">"O"</span>: [
            <span class="string">"editor.action.insertLineBefore"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
</code></pre>
<p>Now we can test the commands we just created.</p>
<p><img src="../images/mode-switching.gif" alt="mode switching"></p>
<h2 id="cursor-movement">Cursor Movement</h2>
<p>The next task in hand is to add commands for moving the cursor. As all Vim users
know, instead of arrow keys, we move the cursor with <code>h</code>, <code>j</code>, <code>k</code>, and <code>l</code>
keys. Before implementing these, let's talk a bit about text selection.</p>
<h3 id="selecting-text">Selecting Text</h3>
<p>In Vim, there is a separate &quot;visual&quot; mode that you activate when you want to
select text. Visual mode can be characterwise or linewise. VS Code has no
simillar concept. By contrast, to select text you move the cursor with <code>Shift</code>
key depressed.</p>
<p>ModalEdit bridges this gap by providing the special command
<code>modaledit.toggleSelection</code> which toggles selection mode on and off. Selection
mode is not really a mode in the same sense as normal and insert mode are; you
can select text both in normal mode and insert mode. Rather it is an additional
flag that you can set when you want to select text as you move the cursor.</p>
<p>Selection mode is also implicitly on whenever there is text selected. If you
select text with mouse, for example, the selection mode is turned on (Vim
behaves like this too). To turn off the selection mode, call
<code>modaledit.toggleSelection</code> again (or <code>modaledit.clearSelection</code>).</p>
<p>The end result is that selection mode works <em>almost</em> like visual mode in Vim,
the main difference being that selection mode is not automatically turned off
when you enter insert mode.</p>
<p>So, let's add a binding to toggle selection mode on or off. We use the familiar
<code>v</code> key for this.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"v"</span>: <span class="string">"modaledit.toggleSelection"</span>,
</code></pre>
<p>Now we can add commands for cursor movement. These commands use the generic
<a href="https://code.visualstudio.com/api/references/commands"><code>cursorMove</code> command</a> which takes arguments. The arguments we use
are partly constant and partly dynamic. Therefore, we use ModalEdit's feature
which allows us to define parameters as a JS expression. The <code>__selecting</code> flag
in the expression indicates whether selection mode is on. The same effect could
be achieved also with a conditional command, but this way is a bit simpler.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"h"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'left', select: __selecting }"</span>
        },
        <span class="string">"j"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'down', select: __selecting }"</span>
        },
        <span class="string">"k"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'up', select: __selecting }"</span>
        },
        <span class="string">"l"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'right', select: __selecting }"</span>
        },
</code></pre>
<p>We can also simulate linewise visual mode using VS Code's <code>expandLineSelection</code>
command. Note that we don't need to call <code>modaledit.toggleSelection</code> this time
as selection mode is turned on automatically.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"V"</span>: <span class="string">"expandLineSelection"</span>,
</code></pre>
<h3 id="moving-inside-screen">Moving Inside Screen</h3>
<p>To move cursor quickly to the top, middle, or bottom of the screen we use keys
<code>H</code>, <code>M</code>, and <code>L</code>. Again, we need to use the <a href="https://code.visualstudio.com/api/references/commands"><code>cursorMove</code> command</a>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"H"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'viewPortTop', select: __selecting }"</span>
        },
        <span class="string">"M"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'viewPortCenter', select: __selecting }"</span>
        },
        <span class="string">"L"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'viewPortBottom', select: __selecting }"</span>
        },
</code></pre>
<h3 id="jumping-to-previous-next-word">Jumping to Previous/Next Word</h3>
<p>Other commonly used navigation commands in Vim include <code>w</code> and <code>b</code> which move
the cursor to the start of the next and previous word. For these we need to use
conditional commands because <code>cursorMove</code> falls short in this use case.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"w"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
            <span class="string">"true"</span>: <span class="string">"cursorWordStartRightSelect"</span>,
            <span class="string">"false"</span>: <span class="string">"cursorWordStartRight"</span>
        },
        <span class="string">"b"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
            <span class="string">"true"</span>: <span class="string">"cursorWordStartLeftSelect"</span>,
            <span class="string">"false"</span>: <span class="string">"cursorWordStartLeft"</span>
        },
</code></pre>
<p><code>e</code> jumps to the end of the next word.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"e"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
            <span class="string">"true"</span>: <span class="string">"cursorWordEndRightSelect"</span>,
            <span class="string">"false"</span>: <span class="string">"cursorWordEndRight"</span>
        },
</code></pre>
<blockquote>
<p><strong>Note</strong>: We omit variants of these commands <code>W</code>, <code>B</code>, and <code>E</code> which skip the
punctuation characters. There are no built-in commands in VS Code that work
exactly like those in Vim. This is one of the subtle differences between the
editors.</p>
</blockquote>
<h3 id="jumping-to-start-end-of-line">Jumping to Start/End of Line</h3>
<p>In the similar vein, we'll throw in commands for jumping to the beginning <code>0</code>,
to the first non-blank character <code>^</code>, and to the end of line <code>$</code>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"0"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'wrappedLineStart', select: __selecting }"</span>
        },
        <span class="string">"^"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'wrappedLineFirstNonWhitespaceCharacter', select: __selecting }"</span>
        },
        <span class="string">"$"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'wrappedLineEnd', select: __selecting }"</span>
        },
</code></pre>
<p>A lesser known variant of above commands is <code>g_</code> that jumps to the last
non-blank character of the line. Since it is a two key sequence we need to
open a block for all commands beginning with <code>g</code>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"g"</span>: {
            <span class="string">"_"</span>: {
                <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
                <span class="string">"args"</span>: <span class="string">"{ to: 'wrappedLineLastNonWhitespaceCharacter', select: __selecting }"</span>
            },
</code></pre>
<h3 id="jumping-to-start-end-of-document">Jumping to Start/End of Document</h3>
<p>Another command beginning with <code>g</code> is <code>gg</code> which jumps to the beginning of the
file.</p>

<pre class="syntaxhighlight"><code>            <span class="string">"g"</span>: {
                <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
                <span class="string">"true"</span>: <span class="string">"cursorTopSelect"</span>,
                <span class="string">"false"</span>: <span class="string">"cursorTop"</span>
            },
        },
</code></pre>
<p>The opposite of that is <code>G</code> wich jumps to the end of file.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"G"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
            <span class="string">"true"</span>: <span class="string">"cursorBottomSelect"</span>,
            <span class="string">"false"</span>: <span class="string">"cursorBottom"</span>
        },
</code></pre>
<h3 id="jump-to-character">Jump to Character</h3>
<p>We have the basic movement commands covered, so let's move on to more
sophisticated ones. Seasoned Vim users avoid hitting movement commands
repeatedly by using <code>f</code> and <code>F</code> keys which move directly to a given character.
VS Code provides no built-in command for this, but ModalEdit includes an
incremental search command which can be customized to this purpose.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"f"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
            <span class="string">"true"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.search"</span>,
                <span class="string">"args"</span>: {
                    <span class="string">"caseSensitive"</span>: <span class="literal">true</span>,
                    <span class="string">"acceptAfter"</span>: <span class="number">1</span>,
                    <span class="string">"selectTillMatch"</span>: <span class="literal">true</span>,
                }
            },
            <span class="string">"false"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.search"</span>,
                <span class="string">"args"</span>: {
                    <span class="string">"caseSensitive"</span>: <span class="literal">true</span>,
                    <span class="string">"acceptAfter"</span>: <span class="number">1</span>,
                    <span class="string">"typeAfterAccept"</span>: <span class="string">"h"</span>,
                }
            },
        },
</code></pre>
<p>The command is a bit involved, so let's explain what each argument does.</p>
<ul>
<li><code>caseSensitive</code> sets the search mode to case sensitive (as in Vim).</li>
<li><code>acceptAfter</code> ends the incremental search as soon as first entered character
is found. Normally the user needs to press <code>Enter</code> to accept the search or
<code>Esc</code> to cancel it.</li>
<li><code>selectTillMatch</code> argument controls whether selection is extended until the
searched character. This depends on whether we have selection mode on or not.</li>
<li><code>typeAfterAccept</code> argument allows you to run other commands (using their key
bindings) after the search is done. By default, <code>modalEdit.search</code> command
selects the found character(s). With <code>h</code> command we move the cursor over the
searched character.</li>
</ul>
<p>Now we can implement the opposite <code>F</code> command which searches for the previous
character. The <code>backwards</code> parameter switches the search direction.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"F"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
            <span class="string">"true"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.search"</span>,
                <span class="string">"args"</span>: {
                    <span class="string">"caseSensitive"</span>: <span class="literal">true</span>,
                    <span class="string">"acceptAfter"</span>: <span class="number">1</span>,
                    <span class="string">"selectTillMatch"</span>: <span class="literal">true</span>,
                    <span class="string">"backwards"</span>: <span class="literal">true</span>,
                }
            },
            <span class="string">"false"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.search"</span>,
                <span class="string">"args"</span>: {
                    <span class="string">"caseSensitive"</span>: <span class="literal">true</span>,
                    <span class="string">"acceptAfter"</span>: <span class="number">1</span>,
                    <span class="string">"typeAfterAccept"</span>: <span class="string">"h"</span>,
                    <span class="string">"backwards"</span>: <span class="literal">true</span>
                }
            },
        },
</code></pre>
<p>With <code>;</code> and <code>,</code> keys you can repeat the previous <code>f</code> or <code>F</code> commands either
forwards or backwards.</p>

<pre class="syntaxhighlight"><code>        <span class="string">";"</span>: <span class="string">"modaledit.nextMatch"</span>,
        <span class="string">","</span>: <span class="string">"modaledit.previousMatch"</span>,
</code></pre>
<blockquote>
<p>We omitted few useful jump commands, like <code>t</code>, <code>T</code>, <code>{</code>, and <code>}</code> as there are
no corresponding commands in available in VS Code. You can always look for
other <a href="https://marketplace.visualstudio.com/">extensions</a> that provide similar functionality.</p>
</blockquote>
<h3 id="center-cursor-on-screen">Center Cursor on Screen</h3>
<p>The last movement command we add is <code>zz</code> that scrolls the screen so that cursor
is at the center. Again, the ability to use JS expression in arguments comes in
handy. We use the <code>__line</code> parameter to get the line where the cursor is.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"z"</span>: {
            <span class="string">"z"</span>: {
                <span class="string">"command"</span>: <span class="string">"revealLine"</span>,
                <span class="string">"args"</span>: <span class="string">"{ lineNumber: __line, at: 'center' }"</span>
            }
        },
</code></pre>
<p>Let's test some of the movement commands. We should be able to navigate now
without using arrow keys or <code>Home</code> and <code>End</code> keys.</p>
<p><img src="../images/cursor-movement.gif" alt="Navigation"></p>
<p>We skipped commands that move cursor up and down on page at the time. The
reason for this is that these commands are bound to <code>Ctrl+b</code> and <code>Ctrl+f</code> in
Vim. Since these are &quot;normal&quot; VS Code shortcuts we cannot remap them in
ModalEdit. If you want to use these shortcuts, you need to add the bindings to
the VS Code's <code>keybindings.json</code> file. Below is an example that uses the
<code>modaledit.normal</code> context to make the shortcuts work only in normal mode. Most
of the Vim's standard <code>Ctrl</code>+key combinations are already in use, so you
need to decide whether you want to remap the existing commands first.</p>

<pre class="syntaxhighlight"><code><span class="comment">// keybindings.json</span>
{
    {
        <span class="string">"key"</span>: <span class="string">"ctrl+b"</span>,
        <span class="string">"command"</span>: <span class="string">"cursorPageUp"</span>,
        <span class="string">"when"</span>: <span class="string">"editorTextFocus &amp;&amp; modaledit.normal"</span>
    },
    {
        <span class="string">"key"</span>: <span class="string">"ctrl+f"</span>,
        <span class="string">"command"</span>: <span class="string">"cursorPageDown"</span>,
        <span class="string">"when"</span>: <span class="string">"editorTextFocus &amp;&amp; modaledit.normal"</span>
    }
}
</code></pre>
<h2 id="commands-with-counts">Commands with Counts</h2>
<p>Some commands allow repeating them by typing first a number. For example, <code>3j</code>
moves the cursor down three lines. Implementing these kind of commands is
possible starting from ModalEdit version 1.5 which introduced key ranges and
<a href="https://johtela.github.io/vscode-modaledit/docs/README.html#defining-recursive-keymaps">recursive keymaps</a>.</p>
<p>First of all, we define a keymap that is activated when pressing a number key
<code>1-9</code>. We give the keymap an unique <code>id</code> which we can then recursively &quot;call&quot;.
We also add a <code>help</code> string that is shown in the status when the keymap is
active (after user has pressed a number key).</p>
<p>Then we define the recursive part; we want to stay in the same keymap as long
as user presses another number key. We implement this by defining inner key
range <code>0-9</code> which maps to the <code>id</code> 1. Whenever you specify a number as the
target for a mapping, ModalEdit treats it as an <code>id</code> that has to be assigned to
a previously defined keymap. In this case we map back to the same keymap, but
you can also jump to other keymaps too.</p>
<p>When the user presses some other than numeric key, we break out from the loop
and run an actual command. The number that was typed is stored in the <code>__keys</code>
variable which is available to all JS expressions. In this case we use it to get
the repeat count as a number. The JS expression in the <code>repeat</code> argument does
just this. We also get the actual command from the last item of the <code>__keys</code>
array and pass it to the <code>modaledit.typeNormalKeys</code> which runs the command
mapped to the key.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"1-9"</span>: {
            <span class="string">"id"</span>: <span class="number">1</span>,
            <span class="string">"help"</span>: <span class="string">"Enter count followed by [h,j,k,l,w,b,e]"</span>,
            <span class="string">"0-9"</span>: <span class="number">1</span>,
            <span class="string">"h,j,k,l,w,b,e"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.typeNormalKeys"</span>,
                <span class="string">"args"</span>: <span class="string">"{ keys: __keys[__keys.length - 1] }"</span>,
                <span class="string">"repeat"</span>: <span class="string">"Number(__keys.slice(0, -1).join(''))"</span>
            },
</code></pre>
<p>With this one reletively simply mapping we can implement the repeating
functionality for any command that we have already defined.</p>
<h3 id="jumping-to-line">Jumping to Line</h3>
<p>Another command that has a number prefix is <em>x</em><code>G</code> where <em>x</em> is the line number
you want to jump to. Let's add that as well in the same keymap. While the
mapping is trivial the command itself is a bit involved, because we need to use
two commands to do the jumping. First we move the target line to the top of the
screen, and then we move the cursor to the same line. Unfortunately the
built-in command <code>workbench.action.gotoLine</code> does not take any arguments, so
we have to reinvent the wheel.</p>

<pre class="syntaxhighlight"><code>            <span class="string">"G"</span>: [
                {
                    <span class="string">"command"</span>: <span class="string">"revealLine"</span>,
                    <span class="string">"args"</span>: <span class="string">"{ lineNumber: Number(__keys.slice(0, -1).join('')) - 1, at: 'top' }"</span>
                },
                {
                    <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
                    <span class="string">"args"</span>: {
                        <span class="string">"to"</span>: <span class="string">"viewPortTop"</span>
                    }
                }
            ]
        },
</code></pre>
<h2 id="editing">Editing</h2>
<p>Now we'll implement Vim's common editing commands. We only add the ones that
have counterparts in VS Code.</p>
<h3 id="joining-lines">Joining Lines</h3>
<p><code>J</code> joins current and next line together.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"J"</span>: <span class="string">"editor.action.joinLines"</span>,
</code></pre>
<h3 id="changing-text">Changing Text</h3>
<p><em>Change</em> commands delete some text and then enter insert mode. <code>cc</code> changes the
current line (or all selected lines), <code>c$</code> changes the text from the cursor to
the end of line, and <code>cw</code> changes the end of the word. Three key sequnce <code>ciw</code>
changes the whole word under the cursor.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"c"</span>: {
            <span class="string">"c"</span>: [
                <span class="string">"deleteAllLeft"</span>,
                <span class="string">"deleteAllRight"</span>,
                <span class="string">"modaledit.enterInsert"</span>
            ],
            <span class="string">"$"</span>: [
                <span class="string">"deleteAllRight"</span>,
                <span class="string">"modaledit.enterInsert"</span>
            ],
            <span class="string">"w"</span>: [
                <span class="string">"deleteWordEndRight"</span>,
                <span class="string">"modaledit.enterInsert"</span>
            ],
</code></pre>
<h3 id="change-until-around-inside">Change Until/Around/Inside</h3>
<p>Very useful variants of change commands are those which allow changing text
upto a given character or between given characters. For example, <code>ct_</code> changes
the text until next underscore, and <code>ci&quot;</code> changes the text inside quotation
marks. The cursor can be anywhere inside the quotation marks and the command
still works.</p>
<p>To help implement these type of operations version 1.6 included the
<a href="https://johtela.github.io/vscode-modaledit/docs/README.html#selecting-text-between-delimiters"><code>modaledit.selectBetween</code> command</a>. It is a swiss army knife
type of command that serves many use cases. We use it first to implement the
&quot;change until&quot; commands: <code>ct</code><em>x</em> changes the text fromthe cursor till the next
occurrence of <em>x</em>. <code>cf</code><em>x</em> does the same and deletes <em>x</em> too.</p>

<pre class="syntaxhighlight"><code>            <span class="string">"t,f"</span>: {
                <span class="string">"help"</span>: <span class="string">"Change until _"</span>,
                <span class="string">" -~"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ to: __keys[2], inclusive: __keys[1] == 'f' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ]
            },
</code></pre>
<p>We exploit key ranges to capture all visible ASCII character from spacebar to
tilde. We find the next occurrence of the character typed last (found in
<code>__keys[2]</code>) and select the range. Note that <code>selectBetween</code> only searches till
the end of the current line by default. If you want to search till the end of
the whole document, set the <code>docScope</code> flag to <code>true</code>. When only the <code>to</code>
argument is specified, the selection starts from the cursor position.</p>
<p>If the user pressed <code>f</code> instead of <code>t</code> as the second key in the sequence, we
set the <code>inclusive</code> flag to true. That extends the selection over the searched
character.</p>
<p>Next we add the change around/inside commands. The first variant takes care of
the characters that are not braces.</p>

<pre class="syntaxhighlight"><code>            <span class="string">"a,i"</span>: {
                <span class="string">"help"</span>: <span class="string">"Change around/inside _"</span>,
                <span class="string">" -/,:-@,[-`,{-~"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ from: __keys[2], to: __keys[2], inclusive: __keys[1] == 'a' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ],
</code></pre>
<p>The rather cryptic key range captures all visible non-alphanumeric ASCII
characters. The rest of the command is exactly same as in the previous example.
The only difference is that we store the character to be searched into both
<code>from</code> and <code>to</code> arguments.</p>
<p>Now we can add the commands that change text inside braces, such as <code>ci{</code> or
<code>ca]</code>.</p>

<pre class="syntaxhighlight"><code>                <span class="string">"(,)"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ from: '(', to: ')', inclusive: __keys[1] == 'a' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ],
                <span class="string">"{,}"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ from: '{', to: '}', inclusive: __keys[1] == 'a' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ],
                <span class="string">"[,]"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ from: '[', to: ']', inclusive: __keys[1] == 'a' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ],
                <span class="string">"&lt;,&gt;"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ from: '&lt;', to: '&gt;', inclusive: __keys[1] == 'a' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ],
</code></pre>
<p>It is also useful to be able to change the current word the cursor is on. You
can do this by typing <code>ciw</code> (preserves separators) or <code>caw</code>. We use regular
expressions as the delimiters in this case. The <code>\N</code> regular expression matches
all non-alphanumeric characters (except underscore). Note the double escaping
needed to enter the <code>\</code> character. There are other commands we could use to
implement the operation, but this version works reliably in all scenarios.</p>

<pre class="syntaxhighlight"><code>                <span class="string">"w"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ from: '\\\\W', to: '\\\\W', regex: true, inclusive: __keys[1] == 'a' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ]
            }
        },
</code></pre>
<blockquote>
<p>We could also implement delete commands <code>diw</code>, <code>dt-</code>, etc. in the similar
fashion. But for the sake of keeping the tutorial short, we'll leave those
as an exercise.</p>
</blockquote>
<p>A shorthand for <code>c$</code> command is <code>C</code>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"C"</span>: [
            <span class="string">"deleteAllRight"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
</code></pre>
<p><em>Substitution</em> commands do  basically same things as change commands; <code>s</code>
changes the character under cursor, and <code>S</code> is same as <code>cc</code>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"s"</span>: [
            <span class="string">"deleteRight"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
        <span class="string">"S"</span>: [
            <span class="string">"deleteAllLeft"</span>,
            <span class="string">"deleteAllRight"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
</code></pre>
<h3 id="undo-amp-redo">Undo &amp; Redo</h3>
<p>You can undo the last change with <code>u</code>. We also clear the selection to copy Vim's
operation.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"u"</span>: [
            <span class="string">"undo"</span>,
            <span class="string">"modaledit.cancelSelection"</span>
        ],
</code></pre>
<p>Since redo is mapped to `Ctrl+r&quot; by default, we leave this binding as an
exercise to the reader.</p>
<h2 id="visual-selection-commands">Visual (Selection) Commands</h2>
<p>Visual commands operate on the selected text. <code>&lt;</code> and <code>&gt;</code> shift selected text
left or right (indent/outdent).</p>

<pre class="syntaxhighlight"><code>        <span class="string">"&lt;"</span>: <span class="string">"editor.action.outdentLines"</span>,
        <span class="string">"&gt;"</span>: <span class="string">"editor.action.indentLines"</span>,
</code></pre>
<h3 id="clipboard-commands">Clipboard Commands</h3>
<p><code>y</code> yanks, i.e. copies, selected text to clipboard. Following Vim convention, we
also clear the selection.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"y"</span>: [
            <span class="string">"editor.action.clipboardCopyAction"</span>,
            <span class="string">"modaledit.cancelSelection"</span>
        ],
</code></pre>
<p><code>d</code> deletes (cuts) the selected text and puts it to clipboard. Capital <code>D</code>
deletes the rest of the line. <code>x</code> deletes just the character under the cursor.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"d"</span>: <span class="string">"editor.action.clipboardCutAction"</span>,
        <span class="string">"D"</span>: [
            <span class="string">"cursorEndSelect"</span>,
            <span class="string">"editor.action.clipboardCutAction"</span>
        ],
        <span class="string">"x"</span>: [
            <span class="string">"cursorRightSelect"</span>,
            <span class="string">"editor.action.clipboardCutAction"</span>
        ],
</code></pre>
<blockquote>
<p><strong>Note</strong>: If there is no text selected, <code>y</code> and <code>d</code> commands perform exactly
the same actions as <code>yy</code> and <code>dd</code> in Vim. That is, they yank or delete the
current line. Again, one of the subtle differences that is futile to try to
unify.</p>
</blockquote>
<p>For pasting (or <em>putting</em> in Vim parlance) the text in clipboard you have two
commands: <code>p</code> puts the text after the cursor, and <code>P</code> puts it before.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"p"</span>: [
            <span class="string">"cursorRight"</span>,
            <span class="string">"editor.action.clipboardPasteAction"</span>
        ],
        <span class="string">"P"</span>: <span class="string">"editor.action.clipboardPasteAction"</span>,
</code></pre>
<h3 id="switching-case">Switching Case</h3>
<p>Switching selected text to upper or lower case is done with a nifty trick.
We can examine the selection in a conditional command that calls different VS
Code commands based on the expression. The command is bound to the tilde <code>~</code>
character.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"~"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selection == __selection.toUpperCase()"</span>,
            <span class="string">"true"</span>: <span class="string">"editor.action.transformToLowercase"</span>,
            <span class="string">"false"</span>: <span class="string">"editor.action.transformToUppercase"</span>
        },
</code></pre>
<h2 id="marks">Marks</h2>
<p>Marks or bookmarks, as they are more commonly known, provide a handy way to
jump quickly inside documents. Surprisingly, VS Code does not contain this
feature out-of-the-box. Since it is easy to implement, ModalEdit fills the gap
and adds two simple commands: <code>modaledit.defineBookmark</code> and
<code>modaledit.goToBookmark</code>. Using these we can implement Vim's mark commands.</p>
<p>We can support dozens of bookmarks with one mapping using a character range.
To define a bookmark, you type <code>ma</code>, for example, and to jump to that mark,
type <code>`a</code>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"m"</span>: {
            <span class="string">"a-z"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.defineBookmark"</span>,
                <span class="string">"args"</span>: <span class="string">"{ bookmark: __keys[1] }"</span>
            }
        },
        <span class="string">"`"</span>: {
            <span class="string">"a-z"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.goToBookmark"</span>,
                <span class="string">"args"</span>: <span class="string">"{ bookmark: __keys[1] }"</span>
            }
        },
</code></pre>
<h2 id="searching">Searching</h2>
<p>The last category of commands we implement is searching. We use the incremental
search command provided by ModalEdit for this. As in Vim, typing <code>/</code> starts an
incremental search. <code>?</code> starts a search backwards.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"/"</span>: {
            <span class="string">"command"</span>: <span class="string">"modaledit.search"</span>,
            <span class="string">"args"</span>: {
                <span class="string">"caseSensitive"</span>: <span class="literal">true</span>
            }
        },
        <span class="string">"?"</span>: {
            <span class="string">"command"</span>: <span class="string">"modaledit.search"</span>,
            <span class="string">"args"</span>: {
                <span class="string">"caseSensitive"</span>: <span class="literal">true</span>,
                <span class="string">"backwards"</span>: <span class="literal">true</span>
            }
        },
</code></pre>
<p>Jumping to next previous match is done with keys <code>n</code> and <code>N</code>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"n"</span>: <span class="string">"modaledit.nextMatch"</span>,
        <span class="string">"N"</span>: <span class="string">"modaledit.previousMatch"</span>,
</code></pre>
<p>There are some subtle differences in the search functionality as well. Instead
of just highlighting matches ModalEdit selects them. This is preferable
anyway, as replacing needs to be done manually with selection commands. Finally,
<code>modaledit.search</code> does not support regexes. Use VS Code's built-in find
command, if you need regex support.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We have built far from complete but nevertheless usable Vim emulation which
you can tweak in various ways to make it better. The point of this exercise was
to show that you can significantly enhance VS Code's editing experience using
just a simple extension and built-in commands.</p>
<p>When writing ModalEdit my goal was not to provide a new Vim emulation. In fact,
I don't use Vim-style key bindings myself. I find the countless keyboard
combinations in Vim superfuous and inconsistent. I doubt that anybody knows, let
alone <em>uses</em> all the available commands. Using Vim is like working in a
workshop where you have shelves full of bench planes but the only tool you
really need is your trusty No 4 Stanley.</p>
<p><img src="../images/wood-planes.jpg" alt="WTF?"></p>
<p>What I am trying to demonstrate is that you don't need to learn all the magical
Vim facilities to become better at editing. Just keep an eye on what operations
you repeat, and think how you could make them more efficient. Then add commands
that will speed up those operations. Try to make the new commands as general as
possible, and as easy as possible to use. Your text editor should adapt to your
way of working, not the other way around.</p>
<p>The thing that Vim got right, though, is modal editing. It is the laser beam
on the great white shark's head that really makes it cool. Modal editing puts
all the commands at your fingertips, and makes you faster. That is why Vim is
still popular, even though there is lot of competition around. So, the obvious
conclusion is to equip modern editors like VS Code with the same frickin'
laser beam. It requires some training to operate, but when properly configured
will cut through text at the speed of light.</p>
<p>Happy Editing! ð¦ð</p>

        
    </div>
            <div class="stickypane">
                
    <div class="pagemenu">
        <h3>On This Page</h3>
            <ul class="pagetree">
                
            </ul>
    </div>
                
            </div>
        </div>
    </div>
    <script src="js/main.js"></script>
    
</body>
</html>