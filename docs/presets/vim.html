
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ModalEdit - Vim Presets</title>
    <link rel="icon" type="image/icon" href="../images/favicon.png" />
    <link rel="stylesheet" href="../css/main.css" />
    
    
</head>
<body>
    
    <div class="navbar">
        <div class="navmenu">
            
    <a class="title enabled" href="../index.html">
        <img src="../images/escape.svg" />
        <span>ModalEdit</span>
    </a>
    <a class="enabled" href="https://marketplace.visualstudio.com/items?itemName=johtela.vscode-modaledit">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><path d="M537.6 226.6c4.1-10.7 6.4-22.4 6.4-34.6 0-53-43-96-96-96-19.7 0-38.1 6-53.3 16.2C367 64.2 315.3 32 256 32c-88.4 0-160 71.6-160 160 0 2.7.1 5.4.2 8.1C40.2 219.8 0 273.2 0 336c0 79.5 64.5 144 144 144h368c70.7 0 128-57.3 128-128 0-61.9-44-113.6-102.4-125.4zm-132.9 88.7L299.3 420.7c-6.2 6.2-16.4 6.2-22.6 0L171.3 315.3c-10.1-10.1-2.9-27.3 11.3-27.3H248V176c0-8.8 7.2-16 16-16h48c8.8 0 16 7.2 16 16v112h65.4c14.2 0 21.4 17.2 11.3 27.3z"/></svg>
        <span>Download</span>
    </a>
    <a class="enabled" href="https://github.com/johtela/vscode-modaledit">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
        <span>GitHub</span>
    </a>
    <a class="enabled" href="../LICENSE.html">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zM64 72c0-4.42 3.58-8 8-8h80c4.42 0 8 3.58 8 8v16c0 4.42-3.58 8-8 8H72c-4.42 0-8-3.58-8-8V72zm0 64c0-4.42 3.58-8 8-8h80c4.42 0 8 3.58 8 8v16c0 4.42-3.58 8-8 8H72c-4.42 0-8-3.58-8-8v-16zm192.81 248H304c8.84 0 16 7.16 16 16s-7.16 16-16 16h-47.19c-16.45 0-31.27-9.14-38.64-23.86-2.95-5.92-8.09-6.52-10.17-6.52s-7.22.59-10.02 6.19l-7.67 15.34a15.986 15.986 0 0 1-14.31 8.84c-.38 0-.75-.02-1.14-.05-6.45-.45-12-4.75-14.03-10.89L144 354.59l-10.61 31.88c-5.89 17.66-22.38 29.53-41 29.53H80c-8.84 0-16-7.16-16-16s7.16-16 16-16h12.39c4.83 0 9.11-3.08 10.64-7.66l18.19-54.64c3.3-9.81 12.44-16.41 22.78-16.41s19.48 6.59 22.77 16.41l13.88 41.64c19.77-16.19 54.05-9.7 66 14.16 2.02 4.06 5.96 6.5 10.16 6.5zM377 105L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128v-6.1c0-6.3-2.5-12.4-7-16.9z"/></svg>
        <span>License</span>
    </a>
    <a class="enabled" href="../tutorial.html">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M223.7 239l136-136c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9L319.9 256l96.4 96.4c9.4 9.4 9.4 24.6 0 33.9L393.7 409c-9.4 9.4-24.6 9.4-33.9 0l-136-136c-9.5-9.4-9.5-24.6-.1-34zm-192 34l136 136c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9L127.9 256l96.4-96.4c9.4-9.4 9.4-24.6 0-33.9L201.7 103c-9.4-9.4-24.6-9.4-33.9 0l-136 136c-9.5 9.4-9.5 24.6-.1 34z"/></svg>
        <span>Previous: Tutorial</span>
    </a>
    <a class="enabled" href="../src/extension.html">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34zm192-34l-136-136c-9.4-9.4-24.6-9.4-33.9 0l-22.6 22.6c-9.4 9.4-9.4 24.6 0 33.9l96.4 96.4-96.4 96.4c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l136-136c9.4-9.2 9.4-24.4 0-33.8z"/></svg>
        <span>Next: Extension</span>
    </a>
        </div>
        
    <a class="hamburger">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
    </a>
    </div>
    
    <div class="layout">
        <div class="sidepane collapsible">
            
    <div class="tocmenu">
        <h3>Table of Contents</h3>
        
    <ul>
        
    <li>
        
        <a href="../README.html">Home</a>
        
    </li>
    <li>
        
        <a href="../tutorial.html">Tutorial</a>
        
    </li>
    <li>
        
        <a href="vim.html" class="highlight">Vim Presets</a>
        
    </li>
    <li>
        <button class="accordion">
        Implementation
        </button>
            
    <ul>
        
    <li>
        
        <a href="../src/extension.html">Extension</a>
        
    </li>
    <li>
        
        <a href="../src/actions.html">Actions</a>
        
    </li>
    <li>
        
        <a href="../src/commands.html">Commands</a>
        
    </li>
    </ul>
    </li>
    <li>
        
        <a href="../CHANGELOG.html">Change Log</a>
        
    </li>
    <li>
        
        <a href="../LICENSE.html">License</a>
        
    </li>
    </ul>
    </div>
            
    <div class="footer">
        Copyright ¬© 2020 Tommi Johtela
        <div class="ad">
            Created with <a href="https://github.com/johtela/litscript">LiTScript</a>
        </div>
    </div>

        </div>
        <div class="sideicon collapsible">
            
    <a class="hamburger">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
    </a>
        </div>
        <div class="scrollingarea closepopups">
            
    <div class="contentarea">
        <h1 id="modal-edit-2-0-batteries-vimcluded">ModalEdit 2.0: Batteries Vimcluded</h1>
<p><img src="../images/pooh.jpg" alt="" width="375" height="403">
Providing full Vim emulation was not originally a goal of ModalEdit. The idea of
the extension is to provide an engine that allows the user to <a href="../README.html#configuration">map any key
combination to any command provided by VS Code</a>.
However, most users equate modal editing with Vim and are familiar with its
default keybindings. Vim users really love the powerful key sequences that
combine editing operations with cursor motions or text ranges.</p>
<p>ModalEdit has also evolved by taking inspiration from Vim. Many capabilities
were added with the motive to enable some Vim feature that was previously not
possible to implement. With version 2.0 ModalEdit's functionality is now
extensive enough to build a semi-complete Vim emulation. So, here we go...</p>
<p>Adding Vim keybindings as optional presets serves two purposes: it lowers the
barrier of entry for Vim users who don't want to spend the time defining
bindings from ground up. Secondly, Vim presets serve as an example to show
how you can build sophisticated command sequences using the machinery provided
by ModalEdit.</p>
<p><img src="../images/import-preset.png" alt="importing presets" width="553" height="94">
If you are not interested on how the Vim keybindings are implemented and just
want to use them, you can skip this discussion. Just import the presets by
pressing <key>Ctrl</key>+<key>Shift</key>+<key>P</key> and running command
<strong>ModalEdit: Import preset keybindings</strong>. You will be presented a choice to
import either Vim bindings or any presets that you have created yourself. If
you are planning to customize the bindings, or create Vim-style commands from
scratch, this document gives you pointers how to go about doing so.</p>
<h2 id="game-plan">Game Plan</h2>
<p>We start with basic motion commands which are mostly straightforward to
implement. Motions have two modes of operation: normal mode (moving cursor), and
visual mode (extending selection). We make sure all motions work correctly in
both modes. This allows us to reuse these keybindings when implementing more
advanced operations. Our goal is to avoid repetition by building complex
sequences from primitive commands.</p>
<p>In Vim, there are multiple key sequences for a same operation. For example,
you can convert a paragraph upper case by typing
<key>g</key><key>U</key><key>i</key><key>p</key>. You can perform the same
operation using visual mode by typing <key>v</key><key>i</key><key>p</key><key>U</key>.
The trick we use is to convert key sequences that operate on character, word,
line, paragraph, etc. to analagous key sequences that use visual mode. We can
implement all the editing commands just to work on active selection and reuse
these commands with the other key combinations. Consequently, command definition
becomes a string mapping problem. Since we can use JavaScript to expressions to
do string manipulation, these mappings are easy to formulate.</p>
<p><img src="../images/vim-uppercase.gif" alt=""></p>
<p>Many ways to skin a cat...</p>
<h2 id="motions-in-normal-mode">Motions in Normal Mode</h2>
<p>The list of available cursor motion commands is shown below.</p>
<div style="overflow: auto">
<table><thead>
<tr>
<th>Keys</th>
<th>Cursor Motion</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Enter</code></td>
<td>Beginning of next line</td>
</tr>
<tr>
<td><code>Space</code></td>
<td>Next character on right</td>
</tr>
<tr>
<td><code>h</code></td>
<td>Left</td>
</tr>
<tr>
<td><code>j</code></td>
<td>Down</td>
</tr>
<tr>
<td><code>k</code></td>
<td>Up</td>
</tr>
<tr>
<td><code>l</code></td>
<td>Right</td>
</tr>
<tr>
<td><code>0</code></td>
<td>First character on line</td>
</tr>
<tr>
<td><code>$</code></td>
<td>Last character on line</td>
</tr>
<tr>
<td><code>^</code></td>
<td>First non-blank character on line</td>
</tr>
<tr>
<td><code>g_</code></td>
<td>Last non-blank character on line</td>
</tr>
<tr>
<td><code>gg</code></td>
<td>First charater in file</td>
</tr>
<tr>
<td><code>G</code></td>
<td>Last character in file</td>
</tr>
<tr>
<td><code>w</code></td>
<td>Beginning of next word</td>
</tr>
<tr>
<td><code>e</code></td>
<td>End of next word</td>
</tr>
<tr>
<td><code>b</code></td>
<td>Beginning of previous word</td>
</tr>
<tr>
<td><code>W</code></td>
<td>Beginning of next alphanumeric word</td>
</tr>
<tr>
<td><code>B</code></td>
<td>Beginning of previous alphanumeric word</td>
</tr>
<tr>
<td><code>H</code></td>
<td>Top of the screen</td>
</tr>
<tr>
<td><code>M</code></td>
<td>Middle of the screen</td>
</tr>
<tr>
<td><code>L</code></td>
<td>Bottom of the screen</td>
</tr>
<tr>
<td><code>%</code></td>
<td>Matching bracket</td>
</tr>
</tbody>
</table>
</div><p>Now, lets implement all the keybindings listed above.</p>

<pre class="syntaxhighlight"><code>{
    <span class="attr">"keybindings"</span>: {
</code></pre>
<p>Cursor can be advanced in a file with with enter and space. These are not
technically motion commands but included for compatibility.</p>

<pre class="syntaxhighlight"><code>        "\n": [
            "cursorDown",
            {
                "command": "cursorMove",
                "args": {
                    "to": "wrappedLineFirstNonWhitespaceCharacter"
                }
            }
        ],
        " ": "cursorRight",
</code></pre>
<p>Move cursor up/down/left/right.</p>

<pre class="syntaxhighlight"><code>        "h": "cursorLeft",
        "j": "cursorDown",
        "k": "cursorUp",
        "l": "cursorRight",
</code></pre>
<p>Move to first/last character on line. These work also in visual mode.</p>

<pre class="syntaxhighlight"><code>        "0": {
            "command": "cursorMove",
            "args": "{ to: 'wrappedLineStart', select: __selecting }"
        },
        "$": {
            "command": "cursorMove",
            "args": "{ to: 'wrappedLineEnd', select: __selecting }"
        },
</code></pre>
<p>Move to first/last non-blank character on line. Also these ones use the
<code>__selecting</code> flag to check whether we are in visual mode.</p>

<pre class="syntaxhighlight"><code>        "^": {
            "command": "cursorMove",
            "args": "{ to: 'wrappedLineFirstNonWhitespaceCharacter', select: __selecting }"
        },
        "g": {
            "_": {
                "command": "cursorMove",
                "args": "{ to: 'wrappedLineLastNonWhitespaceCharacter', select: __selecting }"
            },
</code></pre>
<p>Moving to the beginning of file is defined as a conditional command to make
it work in visual mode.</p>

<pre class="syntaxhighlight"><code>            "g": {
                "condition": "__selecting",
                "true": "cursorTopSelect",
                "false": "cursorTop"
            },
</code></pre>
<h2 id="other-commands-starting-with-key-g-key">Other Commands Starting with <key>g</key></h2>
<p>Commands starting with <key>g</key> key are bit inconsistent in Vim. Some of
them are basic motion commands, such as <key>g</key><key>_</key> and
<key>g</key><key>g</key>, some are editing commands like <key>g</key><key>J</key>
and <key>g</key><key>U</key>, and some switch between tabs ü§∑‚Äç‚ôÇÔ∏è. Since we have to
define all bindings with the same prefix in same place, we take a detour and add
these commands before continuing with rest of the motion commands.</p>
<div style="overflow: auto">
<table><thead>
<tr>
<th>Keys</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gJ</code></td>
<td>Join lines without space in between</td>
</tr>
<tr>
<td><code>gu</code>&lt;<em>motion</em>&gt;</td>
<td>Convert text specified by &lt;<em>motion</em>&gt; to lowercase</td>
</tr>
<tr>
<td><code>gU</code>&lt;<em>motion</em>&gt;</td>
<td>Convert text specified by &lt;<em>motion</em>&gt; to uppercase</td>
</tr>
<tr>
<td><code>gt</code></td>
<td>Go to next tab</td>
</tr>
<tr>
<td><code>gT</code></td>
<td>Go to previous tab</td>
</tr>
</tbody>
</table>
</div><p>Joining lines without space is done by deleting a character after the join
command.</p>

<pre class="syntaxhighlight"><code>            "J": [
                "editor.action.joinLines",
                "deleteRight"
            ],
</code></pre>
<p>The lower/uppercase transition works with any motion, but since we have not
defined all of them yet, we explain the command structure
<a href="#editing-with-motions">later in the document</a>.
The structure we use here is exactly the same as with <key>d</key> command, for
example.</p>

<pre class="syntaxhighlight"><code>            "u,U": {
                "id": 1,
                "help": "Change case with motion",
                "u,U": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: __cmd.slice(0, -3) + 'V' + __rcmd[0] }"
                },
                "h,j,k,l,w,e,b,W,B,%": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __cmd.slice(0, -3) + __rcmd[0] + __rcmd[1] }"
                },
                "^,$,0,G,H,M,L": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[0] + __rcmd[1] }"
                },
                "g": {
                    "g,_": {
                        "command": "modaledit.typeNormalKeys",
                        "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                    }
                },
                "f,t,F,T": {
                    "help": "Do until _",
                    " -~": {
                        "command": "modaledit.typeNormalKeys",
                        "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                    }
                },
                "a,i": {
                    "help": "Do around/inside _",
                    "w,p,b,B,t, -/,:-@,[-`,{-~": {
                        "command": "modaledit.typeNormalKeys",
                        "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                    }
                },
                "`,'": {
                    "help": "Do until mark _",
                    "a-z": {
                        "command": "modaledit.typeNormalKeys",
                        "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                    }
                }
            },
</code></pre>
<p><key>g</key><key>t</key> and <key>g</key><key>T</key> switch to next/previous
tab.</p>

<pre class="syntaxhighlight"><code>            "t": "workbench.action.nextEditor",
            "T": "workbench.action.previousEditor"
        },
</code></pre>
<h2 id="rest-of-the-motion-commands">Rest of the Motion Commands</h2>
<p>Now we can complete the list of basic motion commands. This one movest the
cursor at the end of the file and selects the range, if visual mode is on.</p>

<pre class="syntaxhighlight"><code>        "G": {
            "condition": "__selecting",
            "true": "cursorBottomSelect",
            "false": "cursorBottom"
        },
</code></pre>
<p>The logic of separating words is bit different in VS Code and Vim, so we will
not try to imitate Vim behavior here. These keys are mapped to the most similar
motion available. The <key>W</key> and <key>B</key> commands skip separator
characters, and move to the start of the next/previous alphanumeric word.</p>

<pre class="syntaxhighlight"><code>        "w": "cursorWordStartRight",
        "e": "cursorWordEndRight",
        "b": "cursorWordStartLeft",
        "W": {
            "command": "cursorWordStartRight",
            "repeat": "__char.match(/\\W/)"
        },
        "B": {
            "command": "cursorWordStartLeft",
            "repeat": "__char.match(/\\W/)"
        },
</code></pre>
<p>Moving cursor to the top, middle, and bottom of the screen is mapped to
<key>H</key> (high), <key>M</key> (middle), and <key>L</key> (low) keys. These
mappings also work in visual mode.</p>

<pre class="syntaxhighlight"><code>        "H": {
            "command": "cursorMove",
            "args": "{ to: 'viewPortTop', select: __selecting }"
        },
        "M": {
            "command": "cursorMove",
            "args": "{ to: 'viewPortCenter', select: __selecting }"
        },
        "L": {
            "command": "cursorMove",
            "args": "{ to: 'viewPortBottom', select: __selecting }"
        },
</code></pre>
<p>Move to matching bracket command is somewhat challenging to implement
consistently in VS Code. This is due to the problem that there are no commands
that do exactly what Vim's motions do. In normal mode we call the
<code>jumpToBracket</code> command which works if the cursor is on top of a bracket, but
does not allow for the selection to be extended. In visual mode we use the
<code>smartSelect.expand</code> command instead to extend the selection to whatever
syntactic scope is above the current selection. In many cases, it is more useful
motion than jumping to a matching bracket, but using it means that we are
diverging from Vim's functionality.</p>

<pre class="syntaxhighlight"><code>        "%": {
            "condition": "__selecting",
            "true": "editor.action.smartSelect.expand",
            "false": "editor.action.jumpToBracket"
        },
</code></pre>
<h2 id="jump-to-a-character">Jump to a Character</h2>
<p>Advanced cursor motions in Vim include jump to character, which is especially
powerful in connection with editing commands. With this motion, we can apply
edits upto or including a specified character. The same motions work also as
jump commands in normal mode. We have to provide separate implementations for
normal and visual mode, since we need to provide different parameters to the
<code>modaledit.search</code> command we are utilizing.</p>
<div style="overflow: auto">
<table><thead>
<tr>
<th>Keys</th>
<th>Cursor Motion</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>f</code>&lt;<em>char</em>&gt;</td>
<td>Jump to next occurrence of &lt;<em>char</em>&gt;</td>
</tr>
<tr>
<td><code>F</code>&lt;<em>char</em>&gt;</td>
<td>Jump to previous occurrence of &lt;<em>char</em>&gt;</td>
</tr>
<tr>
<td><code>t</code>&lt;<em>char</em>&gt;</td>
<td>Jump to character before the next occurrence of &lt;<em>char</em>&gt;</td>
</tr>
<tr>
<td><code>T</code>&lt;<em>char</em>&gt;</td>
<td>Jump to character after the previous occurrence of &lt;<em>char</em>&gt;</td>
</tr>
<tr>
<td><code>;</code></td>
<td>Repeat previous f, t, F or T motion</td>
</tr>
<tr>
<td><code>,</code></td>
<td>Repeat previous f, t, F or T motion in opposite direction</td>
</tr>
</tbody>
</table>
</div><p>All of these keybindings are implemented using the
<a href="../README.html#incremental-search">incremental search</a> command, just the
parameters are different for each case. Basically we just perform either a
forward or backward search and adjust the cursor position after the character
has been selected. We also need to adjust cursor position before repeating the
search.</p>
<p>The adjustment is done by invoking key bindings <key>h</key> (left) or
<key>l</key> (right), or sometimes by clearing the selection with <key>v</key>
key.</p>

<pre class="syntaxhighlight"><code>        "f": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "typeAfterAccept": "h",
                "typeBeforeNextMatch": "l",
                "typeAfterNextMatch": "h",
                "typeAfterPreviousMatch": "v"
            }
        },
        "F": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "backwards": true,
                "typeAfterAccept": "v",
                "typeAfterNextMatch": "v",
                "typeBeforePreviousMatch": "l",
                "typeAfterPreviousMatch": "h"
            }
        },
        "t": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "typeAfterAccept": "hhv",
                "typeBeforeNextMatch": "ll",
                "typeAfterNextMatch": "hhv",
                "typeBeforePreviousMatch": "h",
                "typeAfterPreviousMatch": "lv"
            }
        },
        "T": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "backwards": true,
                "typeAfterAccept": "lv",
                "typeBeforeNextMatch": "h",
                "typeAfterNextMatch": "lv",
                "typeBeforePreviousMatch": "ll",
                "typeAfterPreviousMatch": "hhv"
            }
        },
</code></pre>
<p>Repeating the motions can be done simply by calling <code>nextMatch</code> or
<code>previousMatch</code>.</p>

<pre class="syntaxhighlight"><code>        ";": "modaledit.nextMatch",
        ",": "modaledit.previousMatch",
</code></pre>
<h2 id="bookmarks">Bookmarks</h2>
<p>You can also combine jump to bookmark motions with editing commands in Vim.
Therefore, we define them along with the other motions. We use the
<a href="../README.html#bookmarks">bookmark commands</a> provided by ModalEdit to implement
these keybindings:</p>
<div style="overflow: auto">
<table><thead>
<tr>
<th>Keys</th>
<th>Cursor Motion</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>m</code>&lt;<em>char</em>&gt;</td>
<td>Define a bookmark and bind it to key &lt;<em>char</em>&gt;</td>
</tr>
<tr>
<td><code>`</code>&lt;<em>char</em>&gt;</td>
<td>Jump to bookmark bound to key &lt;<em>char</em>&gt;</td>
</tr>
<tr>
<td><code>'</code>&lt;<em>char</em>&gt;</td>
<td>Jump to the first non-blank character of the line where bookmark &lt;<em>char</em>&gt; resides</td>
</tr>
</tbody>
</table>
</div><p>Jump commands also work in visual mode.</p>

<pre class="syntaxhighlight"><code>        "m": {
            "help": "Define mark _",
            "a-z": {
                "command": "modaledit.defineBookmark",
                "args": "{ bookmark: __rcmd[0] }"
            }
        },
        "`": {
            "a-z": {
                "command": "modaledit.goToBookmark",
                "args": "{ bookmark: __rcmd[0], select: __selecting }"
            }
        },
        "'": {
            "a-z": [
                {
                    "command": "modaledit.goToBookmark",
                    "args": "{ bookmark: __rcmd[0], select: __selecting }"
                },
                {
                    "command": "cursorMove",
                    "args": "{ to: 'wrappedLineFirstNonWhitespaceCharacter', select: __selecting }"
                }
            ]
        },
</code></pre>
<h2 id="switching-between-modes">Switching between Modes</h2>
<p>Next, we define keybindings that switch between normal, insert, and visual mode:</p>
<div style="overflow: auto">
<table><thead>
<tr>
<th>Keys</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>i</code></td>
<td>Switch to insert mode</td>
</tr>
<tr>
<td><code>I</code></td>
<td>Move to start of line and switch to insert mode</td>
</tr>
<tr>
<td><code>a</code></td>
<td>Move to next character and switch to insert mode</td>
</tr>
<tr>
<td><code>A</code></td>
<td>Move to end of line and switch to insert mode</td>
</tr>
<tr>
<td><code>o</code></td>
<td>Insert line below current line, move on it, and switch to insert mode</td>
</tr>
<tr>
<td><code>O</code></td>
<td>Insert line above current line, move on it, and switch to insert mode</td>
</tr>
<tr>
<td><code>v</code></td>
<td>Switch to visual mode</td>
</tr>
<tr>
<td><code>V</code></td>
<td>Select current line and switch to visual mode</td>
</tr>
</tbody>
</table>
</div><p>These commands have more memorable names such as <code>i</code> = insert, <code>a</code> = append,
and <code>o</code> = open, but above we describe what the commands do exactly instead
of using these names.</p>

<pre class="syntaxhighlight"><code>        "i": "modaledit.enterInsert",
        "I": [
            "cursorHome",
            "modaledit.enterInsert"
        ],
</code></pre>
<p>The <code>a</code> has to check if the cursor is at the end of line. If so, we don't move
right because that would move to next line.</p>

<pre class="syntaxhighlight"><code>        "a": [
            {
                "condition": "__char == ''",
                "false": "cursorRight"
            },
            "modaledit.enterInsert"
        ],
        "A": [
            "cursorEnd",
            "modaledit.enterInsert"
        ],
        "o": [
            "editor.action.insertLineAfter",
            "modaledit.enterInsert"
        ],
        "O": [
            "editor.action.insertLineBefore",
            "modaledit.enterInsert"
        ],
</code></pre>
<p>Note that visual mode is not really a mode. Basically we just set the
<code>__selecting</code> flag that changes the behavior of normal mode commands. Nor is
there a separate line selection mode. We just mimic Vim's behavior using
VS Code's builtin commands that select ranges of text, when the <code>__selecting</code>
flag is on.</p>

<pre class="syntaxhighlight"><code>        "v": "modaledit.toggleSelection",
        "V": [
            {
                "command": "cursorMove",
                "args": {
                    "to": "wrappedLineStart"
                }
            },
            "modaledit.toggleSelection",
            "cursorDownSelect"
        ],
</code></pre>
<h2 id="editing-in-normal-mode">Editing in Normal Mode</h2>
<p>Editing commands in normal mode typically either affect current character or
line, or expect a motion key sequence at the end which specifies the scope of
the edit. Let's first define simple commands that do not require a motion
annex:</p>
<div style="overflow: auto">
<table><thead>
<tr>
<th>Keys</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x</code></td>
<td>Delete character under cursor</td>
</tr>
<tr>
<td><code>X</code></td>
<td>Delete character left of cursor (backspace)</td>
</tr>
<tr>
<td><code>r</code></td>
<td>Replace character under cursor (delete and switch to insert mode)</td>
</tr>
<tr>
<td><code>s</code></td>
<td>Substitute character under cursor (same as <code>r</code>)</td>
</tr>
<tr>
<td><code>S</code></td>
<td>Substitute current line (delete and switch to insert mode)</td>
</tr>
<tr>
<td><code>D</code></td>
<td>Delete rest of line</td>
</tr>
<tr>
<td><code>C</code></td>
<td>Change rest of line (delete and switch to insert mode)</td>
</tr>
<tr>
<td><code>Y</code></td>
<td>Yank (copy) rest of line</td>
</tr>
<tr>
<td><code>p</code></td>
<td>Paste contents of clipboard after cursor</td>
</tr>
<tr>
<td><code>P</code></td>
<td>Paste contents of clipboard at cursor</td>
</tr>
<tr>
<td><code>J</code></td>
<td>Join current and next line. Add space in between</td>
</tr>
<tr>
<td><code>u</code></td>
<td>Undo last change</td>
</tr>
<tr>
<td><code>.</code></td>
<td>Repeat last change</td>
</tr>
</tbody>
</table>
</div><p><key>x</key> and <key>X</key> commands do exactly what <key>Delete</key> and
<key>Backspace</key> keys do.</p>

<pre class="syntaxhighlight"><code>        "x": "deleteRight",
        "X": "deleteLeft",
</code></pre>
<p><key>r</key> and <key>s</key> commands delete character under cursor and enter
insert mode. In Vim <key>r</key> and <key>R</key> keys swith momentarily or
permanently to overwrite mode. Since this mode does not exist in VS Code, we
settle on mapping both keys to the same sequence.</p>

<pre class="syntaxhighlight"><code>        "r,s": [
            "deleteRight",
            "modaledit.enterInsert"
        ],
</code></pre>
<p><key>S</key> substitutes the whole line. We don't need to implement the command
here as we can reuse the <key>c</key><key>c</key> command that we define later.</p>

<pre class="syntaxhighlight"><code>        "S": {
            "command": "modaledit.typeNormalKeys",
            "args": {
                "keys": "cc"
            }
        },
</code></pre>
<p>Deleting in Vim always copies the deleted text into clipboard, so we do that
as well. If you are wondering why we don't use VS Code's cut command, it has a
synchronization issue that sometimes causes the execution to advance to the
next command in the sequence before cutting is done. This leads to strange
random behavior that usually causes the whole line to disappear instead of the
rest of line.</p>

<pre class="syntaxhighlight"><code>        "D": [
            "modaledit.cancelSelection",
            "cursorEndSelect",
            "editor.action.clipboardCopyAction",
            "deleteRight",
            "modaledit.cancelSelection"
        ],
</code></pre>
<p>Again, we utilize existing mappings to implement the <key>C</key> command. It
does same thing as keys <key>D</key><key>i</key> together.</p>

<pre class="syntaxhighlight"><code>        "C": {
            "command": "modaledit.typeNormalKeys",
            "args": {
                "keys": "Di"
            }
        },
</code></pre>
<p>Yanking or copying is always done on selected range. So, we make sure that only
rest of line is selected before copying the range to clipboard. Afterwards we
clear the selection again.</p>

<pre class="syntaxhighlight"><code>        "Y": [
            "modaledit.cancelSelection",
            "cursorEndSelect",
            "editor.action.clipboardCopyAction",
            "modaledit.cancelSelection"
        ],
</code></pre>
<p>Pasting text at cursor is done with <key>P</key> key. Following Vim convention
<key>p</key> pastes text after cursor position. In both cases we clear the
selection after paste, so that we don't accidently end up in visual mode.</p>

<pre class="syntaxhighlight"><code>        "p": [
            "cursorRight",
            "editor.action.clipboardPasteAction",
            "modaledit.cancelSelection"
        ],
        "P": [
            "editor.action.clipboardPasteAction",
            "modaledit.cancelSelection"
        ],
</code></pre>
<p><key>J</key> joins current and next lines together adding a space in between.
There is a built in command that does just this.</p>

<pre class="syntaxhighlight"><code>        "J": "editor.action.joinLines",
</code></pre>
<p>Undoing last change is also a matter of calling built-in command. We clear the
selection afterwards.</p>

<pre class="syntaxhighlight"><code>        "u": [
            "undo",
            "modaledit.cancelSelection"
        ],
</code></pre>
<p>The last &quot;simple&quot; keybinding we define is <key>`</key> that repeats the last
command that changed the text somehow. This command is provided by ModalEdit. It
checks after each key sequence is typed whether it caused a change in file.
If so, it stores the seqeuence as a change. The command just runs the stored
keysequence again.</p>

<pre class="syntaxhighlight"><code>        ".": "modaledit.repeatLastChange",
</code></pre>
<h2 id="editing-with-motions">Editing with Motions</h2>
<p>So, far we have kept the structure of keybindings quite simple. Now we tackle
the types of keybinding that work in tandem with motion commands. Examples of
such commands include:</p>
<p><key>c</key><key>i</key><key>b</key> - Change text inside curly braces <code>{}</code></p>
<p><key>&gt;</key><key>G</key> - Indent rest of the file</p>
<p><key>y</key><key>`</key><key>a</key> - Yank text from cursor position to mark <code>a</code></p>
<p>We can combine any editing command with any motion, which gives us thousands
of possible combinations. First type the command key and then motion which
specifies the position or range you want to apply the command to.</p>
<div style="overflow: auto">
<table><thead>
<tr>
<th>Keys</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d</code>&lt;<em>motion</em>&gt;</td>
<td>Delete range specified by &lt;<em>motion</em>&gt;</td>
</tr>
<tr>
<td><code>c</code>&lt;<em>motion</em>&gt;</td>
<td>Delete range specified by &lt;<em>motion</em>&gt; and switch to insert mode</td>
</tr>
<tr>
<td><code>y</code>&lt;<em>motion</em>&gt;</td>
<td>Yank range specified by &lt;<em>motion</em>&gt; to clipboard</td>
</tr>
<tr>
<td><code>&gt;</code>&lt;<em>motion</em>&gt;</td>
<td>Indent range specified by &lt;<em>motion</em>&gt;</td>
</tr>
<tr>
<td><code>&lt;</code>&lt;<em>motion</em>&gt;</td>
<td>Outdent range specified by &lt;<em>motion</em>&gt;</td>
</tr>
<tr>
<td><code>=</code>&lt;<em>motion</em>&gt;</td>
<td>Reindent (reformat) range specified by &lt;<em>motion</em>&gt;</td>
</tr>
</tbody>
</table>
</div><p>We can define all commands listed above in a single keybinding block. Remember
that our strategy is just to map the key sequences of the edit commands that use
motions to equivalent commands that work in visual mode. We do the specified
motion in visual mode selecting a range of text, and then running the command
on the selection. It does not matter which editing command we run, all of them
can be mapped the same way.</p>

<pre class="syntaxhighlight"><code>        "d,y,c,&lt;,&gt;,=": {
            "id": 2,
            "help": "Edit with motion",
</code></pre>
<p>The motions can be also divided to two categories: repeatable and non-repeatable.
Some motions we can repeat, such as move to next character/word/line, but some
we can only do once, such as move to end of line, beginning of file, or to a
bookmark. Later on we make it possible to run repeatable motions <em>n</em> times by
typing number <em>n</em> before a motion command or an editing command.</p>
<p>We can run all editing commands on the current line by repeating the command
key. For example <key>y</key><key>y</key> yanks current line, and
<key>&lt;</key><key>&lt;</key> outdents current line. By prefixing these commands
with a number, we repeat the command <em>n</em> times. To extract the number <em>n</em> we
slice all but last 2 characters of the key sequence. Then we append <code>V</code> command
to it and lastly the actual editing command. The whole logic resides in the JS
expression in the <code>args</code> property below.</p>
<p>If you are wondering where the number prefix comes from as we don't have any
numbers in the path to our keybinding block, notice that we defined an <code>id</code> for
our block above. We can use this <code>id</code> to jump to the block from other keybinding
blocks. The entered key sequence <code>__cmd</code> contains the full sequence entered by
the user, not just immediate sequence that lead to the block. So, we can extract
the number from the start of the <code>__cmd</code> string.</p>

<pre class="syntaxhighlight"><code>            "d,y,c,&lt;,&gt;,=": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: __cmd.slice(0, -2) + 'V' + (__rcmd[0] =='c' ? 'dO' : __rcmd[0]) }"
            },
</code></pre>
<p>Another thing to note is that we actually have some logic when choosing what
command to run; we transform the <key>c</key> key to <key>d</key><key>O</key>
sequence, which deletes the selected range and then inserts a new line above
cursor. As an example command <key>2</key><key>c</key><key>c</key> actually
maps to command <key>2</key><key>V</key><key>d</key><key>O</key>.</p>
<p>All the other repeatable commands can be defined in almost identical way. For
example the command to yank three words <key>3</key><key>y</key><key>w</key> is
converted to a sequence <key>v</key><key>3</key><key>w</key><key>y</key>.</p>

<pre class="syntaxhighlight"><code>            "h,j,k,l,w,e,b,W,B,%": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: 'v' + __cmd.slice(0, -2) + __rcmd[0] + __rcmd[1] }"
            },
</code></pre>
<p>Non-repeatable motions are even easier. We just basically rearrange the key
sequence and add <key>v</key> key in front.</p>

<pre class="syntaxhighlight"><code>            "^,$,0,G,H,M,L": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: 'v' + __rcmd[0] + __rcmd[1] }"
            },
            "g": {
                "g,_": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                }
            },
</code></pre>
<p>Next motions jump to a character. They are handy when you want to edit text
until a specified character. For example the command
<key>d</key><key>t</key><key>&quot;</key> deletes text until the next quotation mark.
The implementation is exactly same as above, so the command would map to key
sequence <key>v</key><key>t</key><key>&quot;</key><key>d</key>.</p>

<pre class="syntaxhighlight"><code>            "f,t,F,T": {
                "help": "Do until _",
                " -~": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                }
            },
</code></pre>
<p>Doing an edit inside set of delimiters like braces, parenthesis or quotation
marks can be done with the <key>a</key> or <key>i</key> movement. The difference
between them is that <key>a</key> includes the delimiters in the edit whereas
<key>i</key> does not. The desired delimiter is the last key in the sequence.
Special delimiters <key>w</key>, <key>p</key>, <key>b</key>, <key>B</key>, and
<key>t</key> apply the edit inside word, paragraph, parenthesis, curly braces,
and angle brackets respectively.</p>

<pre class="syntaxhighlight"><code>            "a,i": {
                "help": "Do around/inside _",
                "w,p,b,B,t, -/,:-@,[-`,{-~": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                }
            },
</code></pre>
<p>The last motion you can combine with editing commands is jump to tag. It is
convenient when you want to edit long ranges of text that can't fit on screen.
We have two variants of the motion: <key>`</key> edits until the exact mark
location, <key>'</key> until the beginning of line where the mark specified as
the last key resides. Key sequence is rearranged exactly as above.</p>

<pre class="syntaxhighlight"><code>            "`,'": {
                "help": "Do until mark _",
                "a-z": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                }
            }
        },
</code></pre>
<h2 id="commands-prefixed-by-number">Commands Prefixed by Number</h2>
<p>As stated above, you can repeat many motions and edit commands by prefixing
them with number(s). All of the repeatable commands are listed below. We use a
<a href="../README.html#defining-recursive-keymaps">recursive keymap</a> that loops in the
same mapping while you type number keys. After you type letter(s), we invoke the
command designated by the letters &lt;<em>num</em>&gt; times, or perform a jump command to
line &lt;<em>num</em>&gt;.</p>
<div style="overflow: auto">
<table><thead>
<tr>
<th>Keys</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;<em>num</em>&gt;<code>h|j|k|l|w|e|b|W|B|%</code></td>
<td>Repeat motion &lt;<em>num</em>&gt; times</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>u</code></td>
<td>Undo &lt;<em>num</em>&gt; times</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>v|V</code></td>
<td>Select &lt;<em>num</em>&gt; characters/lines</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>s|S</code></td>
<td>Substitute (replace) &lt;<em>num</em>&gt; characters/lines</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>J</code></td>
<td>Join &lt;<em>num</em>&gt; lines</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>gJ</code></td>
<td>Join &lt;<em>num</em>&gt; lines without space in between</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>G|gg</code></td>
<td>Jump to line &lt;<em>num</em>&gt;</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>gu</code>&lt;<em>motion</em>&gt;</td>
<td>Convert the range specified by &lt;<em>motion</em>&gt; repeated &lt;<em>num</em>&gt; times to lowercase</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>gU</code>&lt;<em>motion</em>&gt;</td>
<td>Convert the range specified by &lt;<em>motion</em>&gt; repeated &lt;<em>num</em>&gt; times to uppercase</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>d</code>&lt;<em>motion</em>&gt;</td>
<td>Delete the range specified by &lt;<em>motion</em>&gt; repeated &lt;<em>num</em>&gt; times</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>c</code>&lt;<em>motion</em>&gt;</td>
<td>Change the range specified by &lt;<em>motion</em>&gt; repeated &lt;<em>num</em>&gt; times</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>y</code>&lt;<em>motion</em>&gt;</td>
<td>Yank the range specified by &lt;<em>motion</em>&gt; repeated &lt;<em>num</em>&gt; times</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>&gt;</code>&lt;<em>motion</em>&gt;</td>
<td>Indent the range specified by &lt;<em>motion</em>&gt; repeated &lt;<em>num</em>&gt; times</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>&lt;</code>&lt;<em>motion</em>&gt;</td>
<td>Outdent the range specified by &lt;<em>motion</em>&gt; repeated &lt;<em>num</em>&gt; times</td>
</tr>
<tr>
<td>&lt;<em>num</em>&gt;<code>=</code>&lt;<em>motion</em>&gt;</td>
<td>Reformat the range specified by &lt;<em>motion</em>&gt; repeated &lt;<em>num</em>&gt; times</td>
</tr>
</tbody>
</table>
</div><p>The recursive part of the keymap defined below.</p>

<pre class="syntaxhighlight"><code>        "1-9": {
            "id": 3,
            "help": "Repeat / go to line",
            "0-9": 3,
</code></pre>
<p>If any of the repeatable motions is typed after a number, we just do that motion
&lt;<em>num</em>&gt; times. The <code>parseInt</code> function extracts the number from the beginning of
the key sequence.</p>

<pre class="syntaxhighlight"><code>            "h,j,k,l,w,e,b,W,B,u,%": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: __rcmd[0] }",
                "repeat": "parseInt(__cmd)"
            },
</code></pre>
<p>Repeating <key>v</key> or <key>V</key> command will select &lt;<em>num</em>&gt; characters or
lines.</p>

<pre class="syntaxhighlight"><code>            "v": {
                "command": "cursorRightSelect",
                "repeat": "parseInt(__cmd)"
            },
            "V": {
                "command": "expandLineSelection",
                "repeat": "parseInt(__cmd)"
            },
</code></pre>
<p>Also substitution commands can be repeated. In this case we just remap the
key sequence with the parsed number in front.</p>

<pre class="syntaxhighlight"><code>            "s": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: parseInt(__cmd) + 'vc' }"
            },
            "S": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: parseInt(__cmd) + 'cc' }"
            },
</code></pre>
<p>We can join multiple lines at once, too. This works because the
<code>editor.action.joinLines</code> joins all selected lines. We just have to clear the
selection afterwards.</p>

<pre class="syntaxhighlight"><code>            "J": [
                {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: parseInt(__cmd) + 'VJ' }"
                },
                "modaledit.cancelSelection"
            ],
</code></pre>
<p>Jumping to a line in Vim is also done by entering first a number and then eiter
<key>G</key> or <key>g</key><key>g</key>. The first keybinding we actually
implement, and the second one just remaps to the first one. Implementing jump
to line in VS Code requires two commands</p>

<pre class="syntaxhighlight"><code>            "G": [
                {
                    "command": "revealLine",
                    "args": "{ lineNumber: parseInt(__cmd) - 1, at: 'top' }"
                },
                {
                    "command": "cursorMove",
                    "args": {
                        "to": "viewPortTop"
                    }
                }
            ],
            "g": {
                "g": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: parseInt(__cmd) + 'G' }"
                },
</code></pre>
<p>Joining lines without space in between is implemented by repeating the command.</p>

<pre class="syntaxhighlight"><code>                "J": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: __cmd.slice(-2) }",
                    "repeat": "parseInt(__cmd)"
                },
</code></pre>
<p>Repeating the complex editing commands is just a matter of jumping to their
keymap blocks. If <key>u</key> or <key>U</key> is pressed we jump to block <code>1</code>.
The rest of the editing commands are implemented in block <code>2</code>.</p>

<pre class="syntaxhighlight"><code>                "u,U": 1
            },
            "d,c,y,&lt;,&gt;,=": 2
        },
</code></pre>
<h2 id="searching">Searching</h2>
<p>Searching introduces a pseudo-mode that captures the keyboard and suspends other
commands as long as search is on. Searching commands are shown below.</p>
<div style="overflow: auto">
<table><thead>
<tr>
<th>Keys</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/</code></td>
<td>Start case-sensitive search forwards</td>
</tr>
<tr>
<td><code>?</code></td>
<td>Start case-sensitive search backwards</td>
</tr>
<tr>
<td><code>n</code></td>
<td>Select the next match</td>
</tr>
<tr>
<td><code>p</code></td>
<td>Select the previous match</td>
</tr>
</tbody>
</table>
</div><p><strong>Note</strong>: Searching commands work also with multiple cursors. As in Vim, search
wraps around if top or bottom of file is encountered.</p>

<pre class="syntaxhighlight"><code>        "/": [
            {
                "command": "modaledit.search",
                "args": {
                    "caseSensitive": true,
                    "wrapAround": true
                }
            }
        ],
        "?": {
            "command": "modaledit.search",
            "args": {
                "backwards": true,
                "caseSensitive": true,
                "wrapAround": true
            }
        },
        "n": "modaledit.nextMatch",
        "N": "modaledit.previousMatch",
</code></pre>
<h2 id="miscellaneous-commands">Miscellaneous Commands</h2>
<p>Rest of the normal mode commands are not motion or editing commands, but do
miscellaenous things.</p>
<div style="overflow: auto">
<table><thead>
<tr>
<th>Keys</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:</code></td>
<td>Show command menu (same as <key>Ctrl</key><key>Shift</key><key>P</key>)</td>
</tr>
<tr>
<td><code>zz</code></td>
<td>Center cursor on screen</td>
</tr>
<tr>
<td><code>ZZ</code></td>
<td>Save file and close the current editor (tab)</td>
</tr>
<tr>
<td><code>ZQ</code></td>
<td>Close the current editor without saving</td>
</tr>
</tbody>
</table>
</div><p>Note that <key>Z</key><key>Q</key> command still asks to save the file, if
it has been changed. There is no way to get around this in VS Code.</p>

<pre class="syntaxhighlight"><code>        ":": "workbench.action.showCommands",
        "z": {
            "z": {
                "command": "revealLine",
                "args": "{ lineNumber: __line, at: 'center' }"
            }
        },
        "Z": {
            "help": "Z - Close and save, Q - Close without saving",
            "Z": [
                "workbench.action.files.save",
                "workbench.action.closeActiveEditor"
            ],
            "Q": "workbench.action.closeActiveEditor"
        }
    },
</code></pre>
<h2 id="motions-in-visual-mode">Motions in Visual Mode</h2>
<p>ModalEdit 2.0 adds a new configuration section called <code>selectbidings</code> that has
the same structure as the <code>keybindings</code> section. With it you can now map keys
that act as the lead key of a normal mode sequence to run a commands when
pressed in visual mode. For example keys <key>d</key>, <key>c</key>, and
<key>y</key> work this way. In normal mode they must be followed by a motion
command to specify the range that they are applied, but in visual mode they
run on the selected text.</p>
<p><code>selectbindings</code> section is always checked first when ModalEdit looks for a
mapping for a keypress. If there is no binding defined in <code>selectbindings</code>
then it checks the <code>keybindings</code> section. Note that you can still define normal
mode commands that work differently when selection is active. You can use either
a conditional or parameterized command to check the <code>__selecting</code> flag, and
perform a different action based on that.</p>
<p>We define all the motions that do not yet work correctly in visual mode. The
full list is below:</p>
<div style="overflow: auto">
<table><thead>
<tr>
<th>Keys</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h|j|k|l</code></td>
<td>Select text to left/down/up/right</td>
</tr>
<tr>
<td><code>w</code></td>
<td>Select until beginning of next word</td>
</tr>
<tr>
<td><code>e</code></td>
<td>Select until end of word</td>
</tr>
<tr>
<td><code>b</code></td>
<td>Select until beginning of previous word</td>
</tr>
<tr>
<td><code>W</code></td>
<td>Select until beginning of next alphanumeric word</td>
</tr>
<tr>
<td><code>B</code></td>
<td>Select unting beginning of previous alphanumeric word</td>
</tr>
<tr>
<td><code>f</code>&lt;<em>char</em>&gt;</td>
<td>Select until next occurrence of &lt;<em>char</em>&gt; including it</td>
</tr>
<tr>
<td><code>F</code>&lt;<em>char</em>&gt;</td>
<td>Select until previous occurrence of &lt;<em>char</em>&gt; including it</td>
</tr>
<tr>
<td><code>t</code>&lt;<em>char</em>&gt;</td>
<td>Select until next occurrence of &lt;<em>char</em>&gt; but not including it</td>
</tr>
<tr>
<td><code>T</code>&lt;<em>char</em>&gt;</td>
<td>Select until previous occurrence of &lt;<em>char</em>&gt; but not including it</td>
</tr>
<tr>
<td><code>a</code>&lt;<em>char</em>&gt;</td>
<td>Select text inside &lt;<em>char</em>&gt; including it</td>
</tr>
<tr>
<td><code>i</code>&lt;<em>char</em>&gt;</td>
<td>Select text inside &lt;<em>char</em>&gt; but not including it</td>
</tr>
<tr>
<td><code>aw</code></td>
<td>Select current word including the whitespace around it</td>
</tr>
<tr>
<td><code>iw</code></td>
<td>Select current word not including the whitespace around it</td>
</tr>
<tr>
<td><code>ap</code></td>
<td>Select current paragraph including the whitespace around it</td>
</tr>
<tr>
<td><code>ip</code></td>
<td>Select current paragraph not including the whitespace around it</td>
</tr>
<tr>
<td><code>a( | a) | ab</code></td>
<td>Select text inside parenthesis including them</td>
</tr>
<tr>
<td><code>i( | i) | ib</code></td>
<td>Select text inside parenthesis not including them</td>
</tr>
<tr>
<td><code>a{ | a} | aB</code></td>
<td>Select text inside curly braces including them</td>
</tr>
<tr>
<td><code>i{ | i} | iB</code></td>
<td>Select text inside curly braces not including them</td>
</tr>
<tr>
<td><code>a[ | a]</code></td>
<td>Select text inside brackets including them</td>
</tr>
<tr>
<td><code>i[ | i]</code></td>
<td>Select text inside brackets not including them</td>
</tr>
<tr>
<td><code>a&lt; | a&gt; | at</code></td>
<td>Select text inside ange brackets (tag) including them</td>
</tr>
<tr>
<td><code>i[ | i] | at</code></td>
<td>Select text inside angle brackets (tag) not including them</td>
</tr>
</tbody>
</table>
</div><p>The basic movement commands are otherwise identical to normal mode defintions,
but the actual commands invoked are different. Roughly speaking, we just add
<code>Select</code> at the end of each command.</p>

<pre class="syntaxhighlight"><code>    "selectbindings": {
        "l": "cursorRightSelect",
        "h": "cursorLeftSelect",
        "j": "cursorDownSelect",
        "k": "cursorUpSelect",
        "w": "cursorWordStartRightSelect",
        "e": "cursorWordEndRightSelect",
        "b": "cursorWordStartLeftSelect",
        "W": {
            "command": "cursorWordStartRightSelect",
            "repeat": "__char.match(/\\W/)"
        },
        "B": {
            "command": "cursorWordStartLeftSelect",
            "repeat": "__char.match(/\\W/)"
        },
</code></pre>
<p>Selecting forwards/backwards until a character is found can be implemented with
the <code>modaledit.search</code> command as in normal mode. The difference is in what
parameters we use; we include the <code>selectTillMatch</code> flag, and provide different
<code>typeBefore...</code> and <code>typeAfter...</code> key sequences.</p>

<pre class="syntaxhighlight"><code>        "f": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "selectTillMatch": true
            }
        },
        "F": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "backwards": true,
                "selectTillMatch": true
            }
        },
        "t": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "typeAfterAccept": "h",
                "typeBeforeNextMatch": "l",
                "typeAfterNextMatch": "h",
                "typeBeforePreviousMatch": "h",
                "typeAfterPreviousMatch": "l",
                "selectTillMatch": true
            }
        },
        "T": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "backwards": true,
                "typeAfterAccept": "l",
                "typeBeforeNextMatch": "h",
                "typeAfterNextMatch": "l",
                "typeBeforePreviousMatch": "l",
                "typeAfterPreviousMatch": "h",
                "selectTillMatch": true
            }
        },
</code></pre>
<p>Selecting text inside/around delimiters are motions that are only defined in
visual mode. The motions can be used along with editing commands in normal mode,
but obviously cannot be performed by themselves as they select ranges of text
thus entering visual mode automatically.</p>
<p>All variants of these motions are implemented with the
<a href="../README.html#selecting-text-between-delimiters"><code>modaledit.selectBetween</code> command</a>.
The command takes start and end delimiters, which can be also regular
expressions, and selects the range between these delimiters. The scope of the
search is by default the current line, but for some variants we specify the
<code>docScope</code> parameter which causes the search to consider the whole file.</p>

<pre class="syntaxhighlight"><code>        "a,i": {
            "help": "Select around/inside _",
            "w": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '\\\\W', to: '\\\\W', regex: true, inclusive: __rcmd[1] == 'a' }"
                }
            ],
            "p": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '(?&lt;=\\\\r?\\\\n)\\\\s*\\\\r?\\\\n', to: '(?&lt;=\\\\r?\\\\n)\\\\s*\\\\r?\\\\n', regex: true, inclusive: __rcmd[1] == 'a', docScope: true }"
                }
            ],
            " -/,:-@,[-`,{-~": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: __rcmd[0], to: __rcmd[0], inclusive: __rcmd[1] == 'a' }"
                }
            ],
            "(,),b": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '(', to: ')', inclusive: __rcmd[1] == 'a', docScope: true }"
                }
            ],
            "{,},B": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '{', to: '}', inclusive: __rcmd[1] == 'a', docScope: true }"
                }
            ],
            "[,]": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '[', to: ']', inclusive: __rcmd[1] == 'a', docScope: true }"
                }
            ],
            "&lt;,&gt;,t": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '&lt;', to: '&gt;', inclusive: __rcmd[1] == 'a' }"
                }
            ]
        },
</code></pre>
<h2 id="editing-commands-in-visual-mode">Editing Commands in Visual Mode</h2>
<p>The last pieces of puzzle are editing commands that operate on selected text in
visual mode. They are the same editing operations we already defined in normal
mode, but remarkable simpler in this context. Since VS Code's operations already
work on selected text, we only need to call the built-in commands and clear the
selection afterwards.</p>
<div style="overflow: auto">
<table><thead>
<tr>
<th>Keys</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;</code></td>
<td>Indent selection</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Outdent selection</td>
</tr>
<tr>
<td><code>=</code></td>
<td>Reindent (reformat) selection</td>
</tr>
<tr>
<td><code>d | x</code></td>
<td>Delete (cut) selection</td>
</tr>
<tr>
<td><code>c</code></td>
<td>Change selection (cut and enter insert mode)</td>
</tr>
<tr>
<td><code>y</code></td>
<td>Yank (copy) selection</td>
</tr>
<tr>
<td><code>u</code></td>
<td>Transorm selection to lowercase</td>
</tr>
<tr>
<td><code>U</code></td>
<td>Transorm selection to upppercase</td>
</tr>
</tbody>
</table>
</div><p>Here are the implementations.</p>

<pre class="syntaxhighlight"><code>        "&gt;": [
            "editor.action.indentLines",
            "modaledit.cancelSelection"
        ],
        "&lt;": [
            "editor.action.outdentLines",
            "modaledit.cancelSelection"
        ],
        "=": [
            "editor.action.formatSelection",
            "modaledit.cancelSelection"
        ],
        "d,x": [
            "editor.action.clipboardCopyAction",
            "deleteRight",
            "modaledit.cancelSelection"
        ],
        "c": [
            "editor.action.clipboardCopyAction",
            "deleteRight",
            "modaledit.enterInsert"
        ],
        "y": [
            "editor.action.clipboardCopyAction",
            "modaledit.cancelSelection"
        ],
        "u": [
            "editor.action.transformToLowercase",
            "modaledit.cancelSelection"
        ],
        "U": [
            "editor.action.transformToUppercase",
            "modaledit.cancelSelection"
        ]
    }
}
</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>The list of commands we provided is by no means exhaustive but still contains
literally thousands of key combinations that cover the most commonly used Vim
operations. This is quite a nice achievement considering that we only wrote
about 600 lines of configuration, and most of it is pretty trivial. This
demonstrates that ModalEdit's functionality is powerful enough to build all
kinds of operations that make modal editors like Vim popular.</p>

        
    </div>
            <div class="stickypane">
                
    <div class="pagemenu">
        <h3>On This Page</h3>
            <ul class="pagetree">
                
            </ul>
    </div>
                
            </div>
        </div>
    </div>
    <script src="../js/main.js"></script>
    
</body>
</html>